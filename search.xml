<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>解构与展开</title>
    <url>/2022/02/27/js/destructuring-spread/</url>
    <content><![CDATA[<p>ES6 开始引入了解构和展开的语法特性，使用起来非常方便。但是这些特性的用法还是非常丰富的，可能多数人平常并不太会注意到，本文对其进行了完整的剖析，以作参考。</p>
<p>如果你对相关内容非常熟悉，不妨直接跳到<a href="#quiz">习题部分</a>，测试一下自己的理解，或者你可以在阅读完本文之后使用习题作为回顾。</p>
<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><h2 id="为什么引入解构"><a href="#为什么引入解构" class="headerlink" title="为什么引入解构"></a>为什么引入解构</h2><p>ES6 之前从对象或者数组中提取多个字段的话只能使用多个赋值语句，写法存在重复。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Jackie&#x27;</span></span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Chen&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多次赋值写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = person.<span class="property">firstName</span>, lastName = person.<span class="property">lastName</span>;</span><br></pre></td></tr></table></figure>

<p>使用和对象字面量一致的形式从目标值中一次提取多个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构语法</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = person</span><br></pre></td></tr></table></figure>

<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>解构对象值<code>person</code>，用对象属性<code>firstName</code>的值定义指定名称<code>fn</code>的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">firstName</span>: fn, <span class="attr">lastName</span>: ln &#125; = person</span><br></pre></td></tr></table></figure>

<p>对象属性名称和指定变量名称相同时可以使用简写形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = person</span><br></pre></td></tr></table></figure>

<p>对象解构的写法和对象字面量形式相同，因此也可以使用数字、字符串和计算属性形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用字符串</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="string">&#x27;fizz-buzz&#x27;</span>: fizzBuzz &#125; = &#123; <span class="string">&#x27;fizz-buzz&#x27;</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="number">2</span>: fizzBuzz &#125; = [<span class="literal">undefined</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;fizz-buzz&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; [key]: fizzBuzz &#125; = &#123; <span class="string">&#x27;fizz-buzz&#x27;</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>解构对象的目标值是<code>null/undefined</code>时会报错，因为对象解构要求目标值可以转换为对象<a href="https://262.ecma-international.org/6.0/#sec-requireobjectcoercible">RequireObjectCoercible</a>，Javascript 中除了<code>null/undefined</code>其他值都可以转换为对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 运行时报错 Uncaught TypeError: Cannot destructure property &#x27;a&#x27; of &#x27;null&#x27; as it is null.</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName &#125; = person</span><br></pre></td></tr></table></figure>

<p>使用解构对象形式获取数组中指定下标的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="number">2</span>: c &#125; = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>基础类型值也可以使用对象解构，获取字符串的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; length &#125; = <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>使用数组字面值类似的写法可以解构数组中元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> date = [<span class="string">&#x27;1970&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;01&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [year, month, day] = date</span><br></pre></td></tr></table></figure>

<p>使用单独的逗号可以<strong>跳过</strong>数组中的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> date = [<span class="string">&#x27;1970&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;01&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过元素 month</span></span><br><span class="line"><span class="keyword">const</span> [year, , day] = date</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用在开头，跳过year</span></span><br><span class="line"><span class="keyword">const</span> [, month, day] = date</span><br></pre></td></tr></table></figure>

<p>使用数组解构交换（swap）两个变量，不需要临时变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span></span><br><span class="line">;[x, y] = [y, x]</span><br></pre></td></tr></table></figure>

<p>或者交换已有数组中两个元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">;[arr[<span class="number">2</span>], arr[<span class="number">1</span>]] = [arr[<span class="number">1</span>], arr[<span class="number">2</span>]]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [1,3,2]</span></span><br></pre></td></tr></table></figure>

<p>数组解构的目标值必须是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable_examples">Iterable</a>，实现了迭代器协议<a href="https://262.ecma-international.org/6.0/#sec-getiterator">GetIterator</a>，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeError: &#123;&#125; is not iterable</span></span><br><span class="line"><span class="keyword">const</span> [year, month] = &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h2><p>对象解构支持嵌套形式，可以在同一处解构不同层次的多个属性。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> note = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;My first note&#x27;</span>,</span><br><span class="line">  <span class="attr">date</span>: <span class="string">&#x27;01/01/1970&#x27;</span>,</span><br><span class="line">  <span class="attr">author</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Sherlock&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Holmes&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  id,</span><br><span class="line">  title,</span><br><span class="line">  date,</span><br><span class="line">  <span class="attr">author</span>: &#123; firstName, lastName &#125;,</span><br><span class="line">&#125; = note</span><br></pre></td></tr></table></figure>

<p>注意上边的解构中定义了五个变量，不包括<code>author</code>，嵌套的形式中对应属性名不属于解构变量。如果想同时解构声明<code>author</code>变量的话，使用下面的形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// 定义变量 author</span></span><br><span class="line">  author,</span><br><span class="line">  <span class="comment">// 定义变量 firstName/lastName</span></span><br><span class="line">  <span class="attr">author</span>: &#123; firstName, lastName &#125;,</span><br><span class="line">&#125; = note</span><br></pre></td></tr></table></figure>

<p>数组解构也支持嵌套形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套数组</span></span><br><span class="line"><span class="keyword">const</span> [one, two, [three, four], five] = nestedArray</span><br></pre></td></tr></table></figure>

<p>对象解构和数组解构可以任意形式嵌套。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> note = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;My first note&#x27;</span>,</span><br><span class="line">  <span class="attr">author</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Sherlock&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Holmes&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">tags</span>: [<span class="string">&#x27;personal&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>, <span class="string">&#x27;investigations&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  title,</span><br><span class="line">  <span class="attr">author</span>: &#123; firstName &#125;,</span><br><span class="line">  <span class="attr">tags</span>: [personalTag, writingTag],</span><br><span class="line">&#125; = note</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date)</span><br></pre></td></tr></table></figure>

<p>一个比较特殊的用法是数组解构的其余元素位置可以直接再次使用对象解构形式，这样的语法设计也能够立即，数组其余元素收集得到值是数组类型，数组也是对象，也可以使用对象解构形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a = [2, 3]</span></span><br><span class="line"><span class="keyword">const</span> [, ...a] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// length:  2</span></span><br><span class="line"><span class="keyword">const</span> [, ...&#123; length &#125;] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>反过来则不成立，对象解构的其余属性位置不能嵌套使用数组解构形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syntax error</span></span><br><span class="line"><span class="keyword">let</span> &#123; ...[ ] &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="未匹配模式"><a href="#未匹配模式" class="headerlink" title="未匹配模式"></a>未匹配模式</h2><p>对象和数组解构形式中不存在匹配的元素或者属性时，解构得到的变量值为<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b === undefined</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b === undefined</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>使用等号指定解构变量的默认值，默认值在解构得到<code>undefined</code>时生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b === 2</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b = <span class="number">2</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时使用修改名称和默认值语法</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">prop</span>: p = <span class="number">123</span> &#125; = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b === 2</span></span><br><span class="line"><span class="keyword">var</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="其余元素-属性（Rest-Element-Property）"><a href="#其余元素-属性（Rest-Element-Property）" class="headerlink" title="其余元素/属性（Rest Element/Property）"></a>其余元素/属性（Rest Element/Property）</h2><p>对象解构中可以使用<code>...rest</code>形式将未指定的属性统一收集到<code>rest</code>变量代表的对象中，称为对象的其余属性（Rest Property）。对象解构中只能有一个其余属性，位置必须是最后一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; a, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxError: Rest element must be last element</span></span><br><span class="line"><span class="keyword">var</span> &#123; ..<span class="property">rest</span>, a &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxError: Rest element must be last element 指y</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...y, ...z &#125; = obj;</span><br></pre></td></tr></table></figure>

<p>数组解构中可以使用<code>...rest</code>形式将未指定的数组元素统一收集到<code>rest</code>变量代表的数组中，称为数组的其余元素（Rest Element）。数组解构中只能有一个其余元素（Rest Element），必须是最后一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxError: Rest element must be last element</span></span><br><span class="line"><span class="keyword">var</span> [...rest, a] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>对于多层嵌套的解构形式，可以在每一层都使用一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123; a, ...rest1 &#125;,</span><br><span class="line">  ...rest2</span><br><span class="line">&#125; = obj</span><br></pre></td></tr></table></figure>

<p>其余元素只能对<strong>对象本身</strong>的未被指定的<strong>可枚举属性</strong>进行收集，不包括不可枚举属性和原型对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prototype = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(prototype, &#123;</span><br><span class="line">  <span class="comment">// 只收集 b</span></span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; ...prop &#125; = obj</span><br><span class="line"><span class="comment">// prop: &#123; b: 2 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prop: &#x27;</span>, prop)</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数参数的传递与数组解构处理类似，可以使用其余参数形式（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">RestParameters</a>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">«pattern1», «pattern2»</span>) &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [«pattern1», «pattern2»] = args;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>函数定义中参数可以使用对象解构形式，来实现命名参数（Named Parameter）的效果。命名参数的好处在于参数顺序不影响结果，含义更加清晰，结合参数默认值使用更加灵活。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drawChart</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  size = <span class="string">&#x27;big&#x27;</span>,</span></span><br><span class="line"><span class="params">  coords = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;,</span></span><br><span class="line"><span class="params">  radius = <span class="number">25</span>,</span></span><br><span class="line"><span class="params">&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(size, coords, radius)</span><br><span class="line">  <span class="comment">// do some chart drawing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">drawChart</span>()</span><br><span class="line"><span class="title function_">drawChart</span>(&#123; <span class="attr">size</span>: <span class="string">&#x27;small&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><code>forEach</code></h3><p>数组的<code>forEach</code>函数也是一个典型的使用场景。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using forEach</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(note).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>Javascript 函数只能返回一个值，但是可以返回数组或者对象包含多个值，配合解构语法可以方便的拿到单个数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mousePosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [x, y] = <span class="title function_">mousePosition</span>()</span><br></pre></td></tr></table></figure>

<h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><p>正则表达式匹配返回类数组对象，配合数组解构使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseProtocol</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> parsedURL = <span class="regexp">/^(\w+)\:\/\/([^\/]+)\/(.*)$/</span>.<span class="title function_">exec</span>(url)</span><br><span class="line">  <span class="keyword">if</span> (!parsedURL) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(parsedURL)</span><br><span class="line">  <span class="comment">// [&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;,</span></span><br><span class="line">  <span class="comment">// &quot;https&quot;, &quot;developer.mozilla.org&quot;, &quot;en-US/docs/Web/JavaScript&quot;]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [, protocol, fullhost, fullpath] = parsedURL</span><br><span class="line">  <span class="keyword">return</span> protocol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其余元素"><a href="#其余元素" class="headerlink" title="其余元素"></a>其余元素</h3><p>函数参数和数组解构语法形式一样可以组合使用其余元素和对象解构语法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">...&#123; length &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for loop destructuring binding</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(note)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for loop destructuring assignment</span></span><br><span class="line"><span class="keyword">for</span> ([a, b] <span class="keyword">of</span> [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">]) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Catch-语句"><a href="#Catch-语句" class="headerlink" title="Catch 语句"></a>Catch 语句</h2><p>try 语句的 Catch 分支中也可以定义变量或者使用解构形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (&#123; message &#125;) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解构绑定与赋值"><a href="#解构绑定与赋值" class="headerlink" title="解构绑定与赋值"></a>解构绑定与赋值</h2><p>解构语法分为<a href="https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-destructuring-binding-patterns">解构绑定模式（Destructuring Binding Patterns）</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值（Destructuring Assignment）</a>两大类，二者的写法基本一致，但语义有所不同。解构绑定模式会<strong>声明新变量</strong>，也就是创建标识符绑定（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-BindingIdentifier">Binding Identifier</a>）；解构赋值会对已有的变量进行<strong>赋值</strong>。</p>
<h3 id="解构绑定"><a href="#解构绑定" class="headerlink" title="解构绑定"></a>解构绑定</h3><p>解构绑定模式用来定义变量，可能出现变量声明、for 循环语句、函数参数等处。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量声明语句 VariableDeclarator</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = person</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-of 语句也可以包含变量声明</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> &#123; firstName, lastName &#125; <span class="keyword">of</span> persons) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义参数部分，为函数声明局部变量，机制和变量声明语句类似</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">&#123; firstName, lastName &#125;</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>解构绑定模式定义了变量，所以也遵循变量声明的规则，重复声明变量属于语法错误。</p>
<p>例如在一个解构绑定中声明多个同名变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Jackie&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Chen&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier &#x27;firstName&#x27; has already been declared</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName, firstName &#125; = person</span><br></pre></td></tr></table></figure>

<p>或者在解构绑定中声明已经存在的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Jackie&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Chen&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstName</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier &#x27;firstName&#x27; has already been declared</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName &#125; = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>另外解构绑定是从目标值中提取属性来声明变量，缺少目标值的话也属于语法错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Uncaught SyntaxError: Missing initializer in destructuring declaration</span></span><br><span class="line"><span class="keyword">let</span> &#123; firstName, lastName &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构赋值是表达式，可以出现在任意赋值语句的左侧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName,</span><br><span class="line">  lastName</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值语句 AssignmentExpression</span></span><br><span class="line">;(&#123; firstName, lastName &#125; = person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-of 语句也可以使用赋值形式</span></span><br><span class="line"><span class="keyword">for</span> (&#123; firstName, lastName &#125; <span class="keyword">of</span> persons) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里解构赋值语句需要用括号对包裹起来，形成表达式语句，花括号对开头的语句会被识别为块语句而不是解构赋值表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构赋值形式的语法陷阱，直接使用花括号对会被识别为块语句，可以使用括号对包裹，强制为表达式</span></span><br><span class="line"><span class="keyword">let</span> prop</span><br><span class="line">assert.<span class="title function_">throws</span>(<span class="function">() =&gt;</span> <span class="built_in">eval</span>(<span class="string">&quot;&#123;prop&#125; = &#123; prop: &#x27;hello&#x27; &#125;;&quot;</span>), &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;SyntaxError&#x27;</span>,</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&quot;Unexpected token &#x27;=&#x27;&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>eval</code>函数，因为这属于编译期语法错误，无法正常的直接运行，<code>eval</code>将编译期错误转换为运行时错误，配合测试代码正常运行。</p>
<p>解构绑定中要求名称不能出现重复，属于变量定义本身的语法要求。解构赋值不要求名称唯一，可以出现重复。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">;[a = <span class="number">2</span>, a = <span class="number">3</span>] = [a]</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure>

<p>但是赋值语义要求赋值表达式左侧的形式必须是左值表达式（LeftHandSideExpression），而且是合法的赋值目标。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">[a, a.<span class="property">b</span>] = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a()是左值表达式，但不是合法赋值目标</span></span><br><span class="line">[ <span class="title function_">a</span>() ] = [<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="语法差异"><a href="#语法差异" class="headerlink" title="语法差异"></a>语法差异</h3><p>解构绑定语法和解构赋值语法除了使用的位置不同，其本身都支持对象解构、数组解构、默认值、其余元素属性、嵌套支持等特性，二者的语法定义是非常类似的。</p>
<p>差别在于解构绑定的语义是定义变量，所以递归语法定义的出口是绑定标识符（Binding Identifier），因为变量的定义是用某个值来初始化某个名字。但是解构赋值的语义是把某个值赋值给某个左值（LeftHandSideExpression），标识符代表的变量只是左值的一种形式，还有成员表达式等很多表达式都是合法的左值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.b是一个左值，所以可以使用在解构赋值形式中</span></span><br><span class="line">;[a.<span class="property">b</span>] = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a: &#x27;</span>, a)</span><br></pre></td></tr></table></figure>

<p>左值形式使用在解构绑定形式中是错误的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syntax error</span></span><br><span class="line"><span class="keyword">const</span> [a.<span class="property">b</span>] = [<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<h1 id="展开语法（Spread-Syntax）"><a href="#展开语法（Spread-Syntax）" class="headerlink" title="展开语法（Spread Syntax）"></a>展开语法（Spread Syntax）</h1><p>展开语法和解构中的其余元素都使用<code>...</code>的形式，二者都是特殊语法形式，不是表达式。其余元素是将多个属性或者值收集到一个值中，展开语法正好相反。</p>
<p>展开语法在同一个表达式中可以使用多次，而且不要求在最后一个，而且只能出现在三个固定的语法解构中。</p>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>用在对象初始化表达式（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-object-initializer">Object Initializer</a>）中方便地拷贝对象、扩展对象、合并两个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明式</span></span><br><span class="line"><span class="keyword">let</span> newObj = &#123; a, ...b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令式 等价形式</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(a, b)</span><br></pre></td></tr></table></figure>

<h3 id="与Object-assign的异同"><a href="#与Object-assign的异同" class="headerlink" title="与Object.assign的异同"></a>与<code>Object.assign</code>的异同</h3><p>目标对象被展开或者使用<code>Object.assign</code>创建新对象时，二者都使用<a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-get-o-p">Get</a>操作来获取对象属性值，因此定义了 get 属性的对象得到的结果是 get 属性求值结果而不是 get 属性本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo: 123 &#125;</span></span><br><span class="line"><span class="keyword">const</span> spread = &#123; ...original &#125;</span><br><span class="line"><span class="comment">// &#123; foo: 123 &#125;</span></span><br><span class="line"><span class="keyword">const</span> assign = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, original)</span><br></pre></td></tr></table></figure>

<p>展开语法和<code>Object.assign</code>都值处理对象的可枚举属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">    <span class="attr">inheritedEnumerable</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto, &#123;</span><br><span class="line">    <span class="attr">ownEnumerable</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ownNonEnumerable</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; ownEnumerable: 2 &#125;</span></span><br><span class="line">&#123;...obj&#125;</span><br><span class="line"><span class="comment">// &#123; ownEnumerable: 2 &#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br></pre></td></tr></table></figure>

<p>展开语法和<code>Object.assign</code>语意上的差别在于展开语法使用<a href="https://262.ecma-international.org/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc">Define</a>语义定义属性，<code>Object.assign</code>使用<a href="https://262.ecma-international.org/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver">Set</a>语义设置属性，二者的区别可以参考<a href="https://2ality.com/2016/10/rest-spread-properties.html#spreading-objects-versus-object.assign()">Spreading objects versus Object.assign()</a>。</p>
<h3 id="属性顺序问题"><a href="#属性顺序问题" class="headerlink" title="属性顺序问题"></a>属性顺序问题</h3><p>对象初始化中可以出现多个展开，因此先后顺序有影响，后展开的属性会覆盖之前同名的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span>, <span class="attr">baz</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo: true, bar: 2, baz: 3 &#125;</span></span><br><span class="line">&#123;...obj, <span class="attr">foo</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo: true, bar: 2, baz: 3 &#125;</span></span><br><span class="line">&#123;<span class="attr">foo</span>: <span class="literal">true</span>, ...obj&#125;</span><br></pre></td></tr></table></figure>

<p>即使多个展开之间不存在同名属性情况，对象本身也记录了属性的顺序，字符串属性是按照<strong>插入顺序</strong>（Insertion Order）存储的，<code>for-in</code>属性遍历和<code>Object.keys</code>遵循相同的顺序。</p>
<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>用在数组初始化表达式（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-array-initializer">Array Initializer</a>）中创建新的数组，比使用<code>concat/push/shift</code>等函数创建新数组更方便。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [a, ...b, c, ...d]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开字符串</span></span><br><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stringArray = [...string]</span><br></pre></td></tr></table></figure>

<h2 id="实参列表"><a href="#实参列表" class="headerlink" title="实参列表"></a>实参列表</h2><p>用在函数调用表达式的参数列表（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-argumentlistevaluation">Argument List Evaluation</a>）中，可以替换<code>apply</code>函数的使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用位置</span></span><br><span class="line"><span class="title function_">multiply</span>(...a)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="title function_">multiply</span>(...numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价形式</span></span><br><span class="line">multiply.<span class="title function_">apply</span>(<span class="literal">null</span>, numbers)</span><br></pre></td></tr></table></figure>

<p>对于构造函数调用无法使用<code>apply</code>函数，只能使用展开语法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dateFields = [<span class="number">1970</span>, <span class="number">0</span>, <span class="number">1</span>] <span class="comment">// 1 Jan 1970</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(...dateFields)</span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>使用扩展语法进行对象拷贝是浅拷贝，和使用<code>Object.assign</code>的效果相同。如果存在多层嵌套的对象或者数组，嵌套的属性或者元素是多个拷贝共享的，这可能造成预期之外的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line"><span class="keyword">let</span> b = [...a]</span><br><span class="line"></span><br><span class="line">b.<span class="title function_">shift</span>().<span class="title function_">shift</span>()</span><br><span class="line"><span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Oh no!  Now array &#x27;a&#x27; is affected as well:</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">//  [[], [2], [3]]</span></span><br></pre></td></tr></table></figure>

<h2 id="可展开对象"><a href="#可展开对象" class="headerlink" title="可展开对象"></a>可展开对象</h2><p>对象扩展语法中 null 和 undefined 被忽略而不是报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;...<span class="literal">undefined</span>&#125;</span><br><span class="line">&#123;...<span class="literal">null</span>&#125;</span><br><span class="line">&#123;...<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的展开元素要求被展开的值是 Iterable，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">key1</span>: <span class="string">&#x27;value1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> array = [...obj] <span class="comment">// TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure>

<h1 id="规范解读"><a href="#规范解读" class="headerlink" title="规范解读"></a>规范解读</h1><h2 id="解构绑定模式"><a href="#解构绑定模式" class="headerlink" title="解构绑定模式"></a>解构绑定模式</h2><p>解构绑定的语法分别定义在变量声明、函数参数、<code>for-in</code>语句、<code>catch</code>语句等可以使用的语法位置，参考变量定义语句处的语法定义（<a href="https://tc39.es/ecma262/#sec-destructuring-binding-patterns">Destructuring Binding Patterns</a>）即可。</p>
<h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>绑定模式（BindingPattern）的分为对象绑定（ObjectBindingPattern）和数组绑定模式（ArrayBindingPattern）两种。</p>
<p>对象绑定模式中包括属性列表（BindingPropertyList）和其余属性（BindingRestProperty），属性列表由若干个单独的属性（BindingProperty）组成。单个属性有单名称绑定（SingleNameBinding）和键值对（PropertyName: BindingElement）的形式。其中绑定元素（BindingElement）和数组绑定语法使用的形式，这个定义使得对象绑定能够<strong>嵌套</strong>数组绑定形式。</p>
<p>数组绑定中包含绑定元素列表（BindingElementList）、可忽略元素（Elision）和其余元素（RestBindingElement）。</p>
<ol>
<li>绑定元素列表有若干个绑定元素组成，绑定元素包括单名称绑定（SingleNameBinding）和绑定模式（BidingPattern Initializer）形式，这里的<strong>嵌套定义</strong>使得数组绑定可以嵌套使用数组或者对象绑定形式。</li>
<li>可忽略元素代表单个逗号，表示忽略数组中的某个元素。</li>
<li>其余元素绑定有两种形式，绑定标识符（…BindingIdentifier）和绑定模式（…BindingPattern），这里的嵌套定义又使得其余元素可以嵌套的使用任意的绑定模式。</li>
</ol>
<h3 id="递归求值"><a href="#递归求值" class="headerlink" title="递归求值"></a>递归求值</h3><p>绑定的求值过程和绑定模式的定义解构对应，都是递归形式，整个求值过程就是递归的找到对应的对象属性或者数组元素，进行求值，然后使用名称和值的对在当前的语法环境（EnvironmentRecord）中定义变量。</p>
<p>绑定初始化（<a href="https://tc39.es/ecma262/#sec-runtime-semantics-bindinginitialization">BindingInitialization</a>）代表了绑定模式的整个初始化过程。首先会将绑定目标值转换为对象（RequireObjectCoercible），不能转换为对象的值会在运行时报错。属性绑定初始化（<a href="https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization">PropertyBindingInitialization</a>）对应绑定属性列表的初始化，然后进入到单个属性的初始化过程（<a href="https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization">KeyedBindingInitialization</a>）。<a href="https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization">RestBindingInitialization</a> 处理对象其余属性的绑定，首先创建一个全新的对象，然后使用（<a href="https://tc39.es/ecma262/#sec-copydataproperties">CopyDataProperties</a>）操作将被解构对象的<strong>可枚举属性</strong>拷贝到新的对象上，被拷贝的对象属性排除了绑定模式的绑定名称（BoundNames）语义记录的名称列表。</p>
<p>对于数组模式来说绑定初始化会进入迭代器绑定初始化（<a href="https://tc39.es/ecma262/#sec-runtime-semantics-iteratorbindinginitialization">IteratorBindingInitialization</a>）的过程。首先会从被解构的目标获取迭代器，所以不可迭代的对象运行时会报错。对于数组中的每个元素进行初始化的过程会造成迭代器向前一步，如果元素嵌套了其他绑定模式，会再次进入绑定初始化过程。数组中其余元素的绑定会创建一个新数组，然后将迭代器中的剩余元素逐个添加到新数组中。</p>
<h2 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值的语法定义和解构绑定类似，区别在于一个使用术语绑定（Binding），一个使用术语赋值（Assignment），这也是二者的运行时语义上的差别。</p>
<p>需要注意的是赋值的语义要求被赋值目标形式合法，可以参考这个问题 <a href="https://stackoverflow.com/questions/62710902/are-function-calls-with-arguments-valid-left-hand-side-expressions-according-to">Are function calls with arguments valid left-Hand-Side-Expressions according to ECMAScript</a>。</p>
<p>简单的说就是只有左值才能作为合法的赋值目标，标准中规定了 LeftHandSideExpression 来表示能够出现在赋值语句左边的形式，但是其中有些形式运行时语义上也无法正确赋值，因此有赋值目标类型的概念（ <a href="https://tc39.es/ecma262/#sec-static-semantics-assignmenttargettype">AssignmentTargetType</a>），将 LeftHandSideExpression 的所有可能类型进行划分，能够正确赋值的形式的赋值目标类型为简单（simple），不能正确赋值的形式的赋值目标类型为非法（invalid）。</p>
<h2 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h2><p>对象初始化（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-object-initializer">Object Initializer</a>）中展开语法的属性定义求值过程在属性定义求值（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-propertydefinitionevaluation">PropertyDefinitionEvaluation</a>）中，同样使用<a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-copydataproperties">CopyDataProperties</a>将被展开值的属性拷贝定义到目标对象上。</p>
<p>数组初始化语法中的展开元素（Spread Element）处理由<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-arrayaccumulation">ArrayAccumulation</a>过程规定，被展开的元素也必须满足迭代器协议，通过迭代过程将下标和元素的键值对拷贝定义到新的数组中。</p>
<p>调用表达式参数列表（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-argumentlistevaluation">Argument List Evaluation</a>）中的求值过程和数组初始化语法中类似。</p>
<h1 id="问题与练习"><a href="#问题与练习" class="headerlink" title="问题与练习 "></a>问题与练习 <span id="quiz"></span></h1><ol>
<li>对象解构的目标值是<code>null</code>或者<code>undefined</code>时会发生什么？满足什么条件的值可以数组解构？</li>
<li>对象解构中被解构对象的所有属性值都会被解构么？原型对象上的属性么会被解构么？</li>
<li>解构语法中没有匹配的属性或者元素时如何处理？</li>
<li>解构语法中什么情况下会使用指定的默认值？</li>
<li>解构绑定和解构赋值的语法有哪些相同和差异的地方？</li>
<li>解构绑定和解构赋值的运行时语义上相同么？</li>
<li>解构语法支持对象、数组以及互相嵌套的形式，但是数组语法中使用其余元素时并不对称，为什么这样设计？</li>
<li>展开语法<code>&#123;...null&#125;</code>和<code>&#123;...undefined&#125;</code>运行结果如何？</li>
<li>展开语法会展开目标对象的所有属性么？</li>
<li>使用解构和展开语法实现对象拷贝是深拷贝还是浅拷贝？</li>
<li>展开语法不能拷贝哪些属性？</li>
<li>展开语法和<code>Object.assign</code>进行属性拷贝时有哪些相同和差异的地方？</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="解构（Destructuring）"><a href="#解构（Destructuring）" class="headerlink" title="解构（Destructuring）"></a>解构（Destructuring）</h2><p>下面几个资料介绍了解构语法的用法，其内容都包含在本文中，感兴趣可以进行阅读。</p>
<ol>
<li><a href="https://www.digitalocean.com/community/tutorials/understanding-destructuring-rest-parameters-and-spread-syntax-in-javascript">Understanding Destructuring, Rest Parameters, and Spread Syntax in JavaScript</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring Assignment</a></li>
<li><a href="https://2ality.com/2015/01/es6-destructuring.html">Destructuring and parameter handling in ECMAScript 6</a></li>
<li><a href="https://exploringjs.com/impatient-js/ch_destructuring.html">JavaScript for impatient programmers Chapter 37 Destructuring</a></li>
<li><a href="https://exploringjs.com/impatient-js/ch_callables.html#parameter-handling">JavaScript for impatient programmers Chapter 25.6 Parameter Handling</a></li>
<li><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/">ES6 In Depth: Destructuring</a></li>
<li>《Understanding ECMAScript 6》Chapter 5 Destructuring for Easier Data Access</li>
</ol>
<p><a href="https://github.com/tc39/proposal-object-rest-spread/blob/main/Rest.md">Object Rest Properties for ECMAScript</a>是对象其余属性的语法提案，已经进入正式的 ECMAScript 2018 规范中。</p>
<p>ECMAScript 规范中关于解构绑定、解构赋值、展开语法等特性的规定参考以下章节。</p>
<ol>
<li><a href="https://tc39.es/ecma262/#sec-runtime-semantics-bindinginitialization">Binding Initialization</a></li>
<li><a href="https://tc39.es/ecma262/#sec-destructuring-binding-patterns">Destructuring Binding Patterns</a></li>
<li><a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-destructuring-assignment">Destructuring Assignment</a>。</li>
<li><a href="https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-parameter-lists">Parameter List</a></li>
</ol>
<p><a href="https://eslint.org/docs/rules/prefer-destructuring">prefer-destructuring</a>是 ESLint 中关于解构的规则。</p>
<h2 id="展开（Spread）"><a href="#展开（Spread）" class="headerlink" title="展开（Spread）"></a>展开（Spread）</h2><p>展开语法的介绍可以首先参考 MDN 文档 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">Spread Syntax</a>和<a href="https://2ality.com/2016/10/rest-spread-properties.html#spreading-objects-versus-objectassign">ES2018: Rest/Spread Properties</a>的介绍。</p>
<p>对象其余属性（Rest Property）和展开属性（Spread Property）的语法提案<a href="https://github.com/tc39/proposal-object-rest-spread">Object Rest/Spread Properties for ECMAScript</a>，其中分别对<a href="https://github.com/tc39/proposal-object-rest-spread/blob/main/Rest.md">Rest</a>和<a href="https://github.com/tc39/proposal-object-rest-spread/blob/main/Spread.md">Spread</a>做说明，关于语法的各种使用情况的例子可以作为准确参考。</p>
<p>其余元素（Rest Element）和其余属性（Rest Property）分别对应数组解构和对象解构，可以参考解构部分的规范描述。</p>
<p>Babel 对于展开语法的转换实现在插件<a href="https://babel.dev/docs/en/babel-plugin-proposal-object-rest-spread">@babel/plugin-proposal-object-rest-spread</a>中。</p>
]]></content>
      <categories>
        <category>深入理解Javascript</category>
      </categories>
      <tags>
        <tag>解构</tag>
        <tag>展开</tag>
        <tag>ES6</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript中什么是合法变量名？</title>
    <url>/2022/02/24/js/identifier/</url>
    <content><![CDATA[<h1 id="Javascript-vs-C"><a href="#Javascript-vs-C" class="headerlink" title="Javascript vs C"></a>Javascript vs C</h1><p>下面这段代码在 Javascript 中是合法的变量赋值语句，但是在 C 语言中并不合法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>原因在于 Javascript 和 C 语言对于什么是合法的变量名称规定不同。本文以 ECMAScript 规范的内容为依据，对这个问题做个探讨。文中使用了标识符名称（IdentifierName）、标识符（Identifier）、保留字（ReservedWord）、关键字（Identifier）等规范中的概念，提示大家在阅读的过程中需要注意这些概念之间的联系和区别，否则容易混淆。</p>
<h1 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h1><h2 id="合法形式"><a href="#合法形式" class="headerlink" title="合法形式"></a>合法形式</h2><p>Javascript 引擎对代码进行处理时，首先在编译阶段进行分词操作，将源码划分为不同的种类的单词（Token），然后使用单词流作为后续解析的输入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中有几类分词：</p>
<ol>
<li>数字 <code>1</code></li>
<li><strong>标识符（Identifier）</strong> <code>test1</code>/<code>a</code></li>
<li><strong>保留字（ReservedWord）</strong><code>function</code>/<code>let</code></li>
<li>空白与标点符号</li>
</ol>
<p>函数和变量等位置使用的是标识符类型的 Token，可以由数字、字母组成，另外为了不与数字冲突所以规定标识符不能以数字开头。<code>function</code>/<code>let</code>等固定语法位置使用的单词形式上也符合标识符定义，但是因为用作特殊用途，所以这一类单词被划分为保留字类型。</p>
<p>ECMAScript 规范中<a href="https://262.ecma-international.org/6.0/#sec-names-and-keywords">名称与关键字</a>对名称的合法形式进行了规定，主要涉及三个概念标识符名称（IdentifierName）、标识符（Identifier）和保留字（ReservedWord）。</p>
<ol>
<li>标识符是指能够作为合法的变量名、函数名、类型、属性名等名称的形式</li>
<li>保留字</li>
<li>标识符和保留字的合法形式统称为标识符名称</li>
</ol>
<p>标识符名称的合法形式使用 BNF 语法规定如下。</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IdentifierName ::</span><br><span class="line">  IdentifierStart</span><br><span class="line">  IdentifierName IdentifierPart</span><br><span class="line"></span><br><span class="line">IdentifierStart ::</span><br><span class="line">  IdentifierStartChar</span><br><span class="line">  \ UnicodeEscapeSequence</span><br><span class="line"></span><br><span class="line">IdentifierPart ::</span><br><span class="line">  IdentifierPartChar</span><br><span class="line">  \ UnicodeEscapeSequence</span><br><span class="line"></span><br><span class="line">IdentifierStartChar ::</span><br><span class="line">  UnicodeIDStart</span><br><span class="line">  $</span><br><span class="line">  _</span><br><span class="line"></span><br><span class="line">IdentifierPartChar ::</span><br><span class="line">  UnicodeIDContinue</span><br><span class="line">  $</span><br><span class="line">  <span class="attribute">&lt;ZWNJ&gt;</span></span><br><span class="line">  <span class="attribute">&lt;ZWJ&gt;</span></span><br></pre></td></tr></table></figure>

<p>关键的含义有两点。</p>
<ol>
<li>标识符名称的首字母必须满足 IdentifierStartChar 的规定，也就是可以使用<code>$</code>、<code>_</code>和 Unicode 中能作为名称首字母的字符（UnicodeIDStart）。</li>
<li>标识符名称的后续字母必须满足 IdentifierPartChar 的规定，可以是<code>$</code>、<code>&lt;ZWNJ&gt;</code>、<code>&lt;ZWJ&gt;</code>和 Unicode 中能作为名称后续字母的字符（UnicodeIDContinue）。其中<code>UnicodeIDContinue</code>包含了<code>UnicodeIDStart</code>、<code>_</code>、数字和其他一些合法字符。</li>
</ol>
<p>也就是说后续字符包含的范围比首字符要大。</p>
<p>Javascript 相比于 C 语言允许更多字符作为标识符</p>
<ol>
<li>开头允许 U+0024 (DOLLAR SIGN) and U+005F (LOW LINE)</li>
<li>后续字符允许 U+200C (ZERO WIDTH NON-JOINER) and U+200D (ZERO WIDTH JOINER)</li>
</ol>
<p>这也是文章开头为什么<code>$a = 1</code>在 Javascript 中合法但是在 C 语言中非法的原因。</p>
<h2 id="中文名称"><a href="#中文名称" class="headerlink" title="中文名称"></a>中文名称</h2><p>标识符合法形式中允许使用 Unicode 码点分类 UnicodeIDStart/UnicodeIDContinue，这意味着我们可以使用中文、日文、韩文等字符作为名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 姓 = <span class="string">&#x27;李&#x27;</span></span><br><span class="line"><span class="keyword">const</span> 名 = <span class="string">&#x27;白&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> 问好(姓, 名) &#123;</span><br><span class="line">  <span class="keyword">const</span> greeting = <span class="string">`你好，<span class="subst">$&#123;姓&#125;</span><span class="subst">$&#123;名&#125;</span> 🤪`</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你好，李白 🤪</span></span><br><span class="line">问好(姓, 名)</span><br></pre></td></tr></table></figure>

<p>上面代码中函数名、参数名、变量名都使用了中文，是合法的形式。</p>
<h2 id="UnicodeIDStart-和-UnicodeIDContinue"><a href="#UnicodeIDStart-和-UnicodeIDContinue" class="headerlink" title="UnicodeIDStart 和 UnicodeIDContinue"></a>UnicodeIDStart 和 UnicodeIDContinue</h2><p>完整的 UnicodeIDStart 和 UnicodeIDContinue 包含的字符可以参考<a href="https://www.unicode.org/reports/tr31/">Unicode® Standard Annex #31</a>中 Default Identifier Syntax 的内容。</p>
<p>Babel 对于标识符的相关实现位于<a href="https://github.com/babel/babel/blob/main/packages/babel-helper-validator-identifier/src/identifier.ts">这里</a>，使用库<a href="https://www.npmjs.com/package/@unicode/unicode-14.0.0">Unicode v14.0.0</a>提取合法的码点范围并生成正则表达式来检测合法名称字符。</p>
<p>粗略来说，合法的名称字符包括了几类。</p>
<table>
  <tr>
    <th>码点范围</th>
    <th>分类</th>
    <th>字符</th>
  </tr>
  <tr>
    <td>0x00 - 0xff</td>
    <td>ASCII 字符集</td>
    <td>英文大写字母、小写字母、数字和几个特殊字符$、_</td>
  </tr>
  <tr>
    <td>0x0100 - 0xffff</td>
    <td>Unicode 基础平面 BMP 中的合法字符</td>
    <td>中文、日文、韩文</td>
  </tr>
  <tr>
    <td>0x01000 - 0x10ffff</td>
    <td>Unicode 补充平面（Astral）</td>
    <td>其他字符</td>
  </tr>
</table>

<h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h2><p>Javascript 支持使用 Unicode 转义序列<a href="https://262.ecma-international.org/6.0/#sec-literals-string-literals">UnicodeEscapeSequence</a>来表示 Unicode 字符，方便在不能直接使用 Unicode 字符的情况下使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// \u0041 是字符&#x27;A&#x27;的转义序列</span><br><span class="line">let \u0041 = 1;</span><br><span class="line">console.log(&#x27;A: &#x27;, A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// \u&#123;0042&#125; 是字符&#x27;B&#x27;的转义序列</span><br><span class="line">let \u&#123;0042&#125; = 2;</span><br><span class="line">console.log(&#x27;B: &#x27;, B)</span><br></pre></td></tr></table></figure>

<p>上面使用了 Unicode 转义序列的两种形式分别定义了变量 A 和 B，<code>\uxxxx</code>的形式只能表示 Unicode 中基本平面的字符，<code>\u&#123;xxxxxx&#125;</code>的形式能表示 Unicode 中的所有字符，完整的定义如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnicodeEscapeSequence ::</span><br><span class="line">  u Hex4Digits</span><br><span class="line">  u&#123; CodePoint &#125;</span><br><span class="line"></span><br><span class="line">Hex4Digits ::</span><br><span class="line">  HexDigit HexDigit HexDigit HexDigit</span><br><span class="line"></span><br><span class="line">HexDigit :: one of</span><br><span class="line">  0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</span><br><span class="line"></span><br><span class="line">CodePoint ::</span><br><span class="line">  HexDigits[~Sep] but only if MV of HexDigits ≤ 0x10FFFF</span><br></pre></td></tr></table></figure>

<p>对于错误形式的转译序列，执行时在代码解析阶段就直接报错。</p>
<p><code>\uxxxx</code>形式必须是<code>\u</code>后面跟着四个十六进制字符（HexDigit）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError: Invalid Unicode escape sequence</span></span><br><span class="line"><span class="keyword">const</span> \uaa = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(\uaa)</span><br></pre></td></tr></table></figure>

<p><code>\u&#123;xxxxxx&#125;</code>形式中括号对内也是十六进制字符，但是要求代表的码点值必须小于等于（0x10FFFF），也就是位于 Unicode 字符集规定的码点范围内。</p>
<p>下面是几种非法的转义序列形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误，包含了不属于十六进制字符的字符g</span></span><br><span class="line">\u&#123;1g&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，码点范围超出Unicode字符集</span></span><br><span class="line">\u&#123;<span class="number">110000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，\u&#123;42&#125;是字符B的转义形式</span></span><br><span class="line"><span class="keyword">const</span> \u&#123;<span class="number">42</span>&#125; = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B&#x27;</span>, \u&#123;<span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>转译序列除了必须形式正确外，其代表的对应码点也必须是合法的名称字符。<br>例如反撇号`本身不是合法的名称字符，那么使用转义序列的方式书写也是不正确的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \u&#123;40&#125;是反撇号`的转义序列形式</span></span><br><span class="line"><span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="keyword">const</span> \u&#123;<span class="number">40</span>&#125; = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="码点序列语意"><a href="#码点序列语意" class="headerlink" title="码点序列语意"></a>码点序列语意</h2><p>由于允许使用 Unicode 转义序列，所以同一个名称的变量有多种写法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接书写</span></span><br><span class="line">let A = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转译序列形式</span></span><br><span class="line"><span class="comment">// \u0041是 &#x27;A&#x27;的转义形式</span></span><br><span class="line">let \u0041 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>Javascript 中对于标识符名称的处理都是基于码点序列，具有相同码点序列的不同写法被认为是同一个名称。在 ES6 规范中被称为 <a href="https://262.ecma-international.org/6.0/#sec-identifier-names-static-semantics-stringvalue">StringValue</a> 语意，在 ES 2022 中被称为 <a href="https://tc39.es/ecma262/#sec-identifiercodepoints">IdentifierCodePoints</a> 语意，使用的术语不相同，但表达式是同一个意思。因此上面这段代码执行的话会报错，因为同一个名称’A’的变量不允许<strong>重复定义</strong>。</p>
<p>Unicode 中代表相同字符（canonically equivalent）的标识符名称并不一定等价，除非其使用的码点序列相同，参考 <a href="https://262.ecma-international.org/6.0/#sec-names-and-keywords">ES 6 规范</a>。</p>
<blockquote>
<p>Two IdentifierName that are canonically equivalent according to the Unicode standard are not equal unless, after replacement of each UnicodeEscapeSequence, they are represented by the exact same sequence of code points.</p>
</blockquote>
<h2 id="合法名称判断"><a href="#合法名称判断" class="headerlink" title="合法名称判断"></a>合法名称判断</h2><p>通过上面的介绍我们了解了标识符名称的合法形式的定义，主要是两点。</p>
<ol>
<li>首字母必须合法</li>
<li>后续字母必须合法</li>
</ol>
<p>看起来像是废话，但是具体实现逻辑还是有些细节的，这里我们参考<a href="https://github.com/babel/babel/blob/main/packages/babel-helper-validator-identifier/src/identifier.ts#L85">Babel</a>的实现。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isIdentifierName</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> isFirst = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// iterable protocol返回的是code point序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(name)) &#123;</span><br><span class="line">    <span class="keyword">const</span> cp = char.<span class="title function_">codePointAt</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isIdentifierStart</span>(cp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      isFirst = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isIdentifierChar</span>(cp)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// isFirst理解为状态机，包含了空串、单个字符、多个字符情况</span></span><br><span class="line">  <span class="keyword">return</span> !isFirst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现中有几个关键点。</p>
<p>第一点，接受的参数是一个字符串，需要从字符串获取其对应的 Unicode 码点序列。由于 Javascript 的字符串使用的是 UTF16 的变长编码，所以字符串获得指定下标位置字符对应码点的方法<code>codePointAt(index)</code>不能直接使用，需要增加对于代理对的检查。Babel 的实现没有包含这个检测逻辑，而是直接使用了<code>Array.from(name)</code>的形式。</p>
<p>原因在于字符串实现了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator">迭代器协议</a>，得到一个字符串的迭代器，顺序返回字符串每个字符对应的码点，返回形式也是字符串，所以使用 for 循环遍历时每个字符代表一个码点，使用<code>codePointAt(0)</code>查询即可。</p>
<p>第二点，关于首字母<code>isIdentifierStart</code>和后续字母<code>isIdentifierChar</code>的检测逻辑是前文中讲述的内容。</p>
<p>第三点，整个检测逻辑是一个状态机的实现，<code>isFirst</code>变量可以理解为记录了状态机的匹配状态。状态机的合法结束情况是接受了至少一个字符，而且每个字符都满足对应的要求。状态机结束时函数返回<code>true</code>表示输入是合法的标识符名称。</p>
<p>循环中单个字符非法时直接返回<code>false</code>；如果循环能正确结束表示所有字符合法，这时候还要满足至少一个字符，也就是<code>!isFirst</code>。</p>
<h1 id="名称分类"><a href="#名称分类" class="headerlink" title="名称分类"></a>名称分类</h1><p>下图中对标识符名称、标识符、关键字、保留字等概念的关系进行总结。标识符名称是最大的圈，包含了其他三个概念。保留字和标识符是两个互斥的概念，合起来等于标识符名称。关键字和保留字、标识符各有重合。</p>
<p><img data-src="/images/reserved-word-keyword.jpeg" alt="名称分类"></p>
<p>名称的分类可以参考<a href="https://tc39.es/ecma262/#sec-keywords-and-reserved-words">规范</a>中的表述，其中总是<strong>可以</strong>作为标识符的名称（Math,window,toString 等）和总是<strong>不能</strong>作为标识符的名称（if/else 等）两种情况比较清楚，可以重点关注另外的三种情况<span id="conditional-reserved-word"></span>。</p>
<table>
  <tr>
    <th>分类</th>
    <th>列表</th>
  </tr>
  <tr>
    <td>某些条件下可以作为标识符的保留字</td>
    <td>await, yield</td>
  </tr>
  <tr>
    <td>严格模式下激活的保留字 </td>
    <td>let, static, implements, interface, package, private, protected, public</td>
  </tr>
  <tr>
    <td>可以作为标识符的关键字</td>
    <td>as, async, from, get, meta, of, set, target</td>
  </tr>
</table>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字（keyword）是指符合标识符名称（IdentifierName）形式，且出现在<strong>语法结构</strong>中的若干个单词，例如下面代码中的<code>function/if/return</code>等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数关键字不是合法的标识符，也就是不能出现在需要标识符的语法结构位置中，不能用作变量名、函数名、类名等。但是也有个别关键词<a href="#async-await">例外</a>。</p>
<p>ES 6 中的关键字列表如下，Babel 实现的辅助函数<a href="https://github.com/babel/babel/blob/main/packages/babel-helper-validator-identifier/src/keyword.ts#L94">isKeyword</a>与其一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break case catch continue debugger default do else finally for function if return switch throw try var const while with new this super class extends export import null true false in instanceof typeof void delete</span><br></pre></td></tr></table></figure>

<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p><a href="https://262.ecma-international.org/6.0/#sec-reserved-words">保留字</a>（ReservedWord）是指<strong>标识符名称</strong>中不是<strong>标识符</strong>的其余名称。也就是说一个名称如果属于保留字，那么就不能用到变量名、函数名、类名等需要标识符的语法位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> enum = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中<code>enum</code>是保留字，所以不能作为变量名称使用。但是有些名称作为保留字是<a href="#conditional-reserved-word">有条件的</a>，条件不满足时不是保留字，从而可以作为变量名存在。设计这种机制主要是出于兼容旧代码的考虑，规范新增保留字时，旧代码中可能存在使用新保留字作为变量的情况，为了保证旧代码在新规范下还能正常运行，保留字的触发就需要设置一定条件。</p>
<p>ES2022 中的保留字列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await break case catch class const continue debugger default delete do else enum export extends false finally for function if import in instanceof new null return super switch this throw true try typeof var void while with yield</span><br></pre></td></tr></table></figure>

<h2 id="标识符分类"><a href="#标识符分类" class="headerlink" title="标识符分类"></a>标识符分类</h2><p>标识符根据所处的语法位置表示不同的语义，划分为绑定标识符（BindingIdentifier）、标识符引用（IdentifierReference）、标签标识符（LabelIdentifier）和普通标识符（Identifier）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定标识符，定义一个绑定</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用标识符，引用一个绑定</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 标签标识符，标签语句中使用的形式</span></span><br><span class="line"><span class="attr">a</span>: <span class="variable language_">console</span>.<span class="property">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 是绑定标识符</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// id是普通标识符</span></span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// id是普通标识符</span></span><br><span class="line">obj.<span class="property">id</span></span><br></pre></td></tr></table></figure>

<p>标识符的类型是根据 ECMAScript 规范定义的语法形式确定的，针对具体代码可以查询规范确定。</p>
<p>不同的标识符类型对于合法的标识符名称的要求不同，通过 Javascript 语法规则和静态语意进行约束。</p>
<p>下面讨论的是针对<strong>绑定标识符、引用标识符和标签标识符</strong>，</p>
<p>下文中的“能/不能作为标识符”、“合法标识符”等表述，如无特殊说明其中“标识符”均指<strong>绑定标识符、引用标识符和标签标识符</strong>，普通标识符的名称没有特殊要求，可以使用符合标识符名称的任意内容。</p>
<h1 id="合法标识符"><a href="#合法标识符" class="headerlink" title="合法标识符"></a>合法标识符</h1><h2 id="是关键字但不是保留字"><a href="#是关键字但不是保留字" class="headerlink" title="是关键字但不是保留字"></a>是关键字但不是保留字</h2><p>一部分关键字不是保留字，可以作为合法标识符使用，下面对属于这个分类的情况分别给出代码示例。</p>
<p>模块导入导出语法中的关键字<code>from</code>/<code>as</code>可以作为标识符使用，因此下面的代码是合法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将模块导出到标识符from上，第一个from是标识符，第二个from是关键字</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">from</span> <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;from: &#x27;</span>, <span class="keyword">from</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将readFile导入为as变量，第一个as是关键字，第二个as是标识符</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile <span class="keyword">as</span> <span class="keyword">as</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;as: &#x27;</span>, <span class="keyword">as</span>)</span><br></pre></td></tr></table></figure>

<p>异步函数语法中<code>async</code>关键字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名称为 async的异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>for-of</code>循环中的<code>of</code>关键字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将循环变量命名为of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">of</span> <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">of</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象语法中 get/set 属性或者类定义中 get/set 方法使用到的关键字<code>get</code>/<code>set</code>。</p>
<p>对象属性中用到名称为<code>get</code>/<code>set</code>的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> get = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>) &#123;</span><br><span class="line">      set = value</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中定义名称为 get 的<code>get</code>属性和名称为 set 的<code>set</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;get&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set: &#x27;</span>, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">get</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">set</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Test</span>().<span class="title function_">print</span>()</span><br></pre></td></tr></table></figure>

<p><code>new.target</code>语法中的<code>target</code>关键字可以作为标识符，<code>new</code>是保留字不能作为标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">new</span>.<span class="property">target</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;target: &#x27;</span>, target)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Test</span>()</span><br></pre></td></tr></table></figure>

<p><code>import.meta</code>中的<code>meta</code>关键字作为合法的标识符，<code>import</code>是保留字不能作为标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> meta = <span class="keyword">import</span>.<span class="property">meta</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;meta: &#x27;</span>, meta)</span><br></pre></td></tr></table></figure>

<p>上述这些代码示例虽然合法，但是这种写法容易造成误解，实际编码过程中最好<strong>禁用</strong>这种写法。</p>
<h2 id="严格模式保留字"><a href="#严格模式保留字" class="headerlink" title="严格模式保留字"></a>严格模式保留字</h2><p>严格模式下以下列表中的标识符名称也是保留字，不能作为合法标识符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public</span><br><span class="line">private</span><br><span class="line">protected</span><br><span class="line">interface</span><br><span class="line">package</span><br><span class="line">implements</span><br><span class="line">let</span><br><span class="line">static</span><br><span class="line">yield // 下文有单独讨论</span><br></pre></td></tr></table></figure>

<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>yield 关键字在非严格模式下可以作为合法标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确，非严格模式</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">yield</span> = &#123; <span class="attr">yield</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">yield</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>.<span class="property">yield</span>)</span><br></pre></td></tr></table></figure>

<p>但是<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-identifiers-static-semantics-early-errors">静态语意</a>约束在严格模式下 yield 是保留字，不能作为标识符。</p>
<p>使用’use strict’开启严格模式，下面代码中的的所有 yield 标识符都是非法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">yield</span> = &#123; <span class="attr">yield</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">yield</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>.<span class="property">yield</span>)</span><br></pre></td></tr></table></figure>

<p>但是对象属性的标识符是普通标识符，所以名称为 yield 是合法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">yield</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">yield</span>)</span><br></pre></td></tr></table></figure>

<p>模块代码（Module）中自动开启严格模式，下面的代码是模块代码，<code>yield</code>是保留字，所以定义名称为<code>yield</code>的变量报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError: Unexpected strict mode reserved word</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">yield</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Generator 函数</strong>中不允许使用名称为 yield 关键字的<strong>绑定标识符</strong>，非迭代器函数中无此限制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">yieldIsValidIdentifier</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 普通函数中合法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">yield</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">yieldIsUnexpectedIdentifier</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// SyntaxError: Unexpected identifier</span></span><br><span class="line">  <span class="comment">// 迭代器函数中非法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">yield</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外 Generator 函数中不允许以<strong>转义序列</strong>形式出现名称为 yield 的绑定标识符、引用标识符和标签标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// yield 转义形式</span></span><br><span class="line">  yiel\u&#123;<span class="number">64</span>&#125;: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="await"><a href="#await" class="headerlink" title="await "></a>await <span id="async-await"></span></h2><p>await 关键字在脚本环境中可以作为合法的标识符，严格模式对 await 是否是保留字<strong>无影响</strong>。下面脚本代码中的 await 都是合法标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">await</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">await</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">await</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">await</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">await</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>模块代码</strong>中 await 是保留字，不能用做标识符，下面的代码是<strong>模块代码</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 非法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">await</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">await</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 非法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">await</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>异步函数</strong>中 await 是保留字，不能用做标识符，下面的代码是<strong>脚本代码</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 合法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">await</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法，异步函数的函数名不属于函数内部</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">await</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// SyntaxError: Unexpected reserved word</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">await</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在异步函数中同样也不允许以<strong>转义序列</strong>形式出现名称为 await 的绑定标识符、引用标识符和标签标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// SyntaxError: Keyword must not contain escaped characters</span></span><br><span class="line">  \u&#123;<span class="number">61</span>&#125;<span class="attr">wait</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="yield-await-存疑问题"><a href="#yield-await-存疑问题" class="headerlink" title="yield/await 存疑问题"></a>yield/await 存疑问题</h2><p>规范中关于 yield/await<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-identifiers-static-semantics-early-errors">部分</a>有个问题暂时没搞明白。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 规则1</span><br><span class="line">BindingIdentifier[Yield, Await] : yield</span><br><span class="line">  It is a Syntax Error if this production has a [Yield] parameter.</span><br><span class="line"></span><br><span class="line">// 规则2</span><br><span class="line">BindingIdentifier[Yield, Await] : await</span><br><span class="line">  It is a Syntax Error if this production has an [Await] parameter.</span><br><span class="line"></span><br><span class="line">// 规则3</span><br><span class="line">IdentifierReference[Yield, Await] : Identifier</span><br><span class="line">BindingIdentifier[Yield, Await] : Identifier</span><br><span class="line">LabelIdentifier[Yield, Await] : Identifier</span><br><span class="line">  It is a Syntax Error if this production has a [Yield] parameter and StringValue of Identifier is &quot;yield&quot;.</span><br><span class="line">  It is a Syntax Error if this production has an [Await] parameter and StringValue of Identifier is &quot;await&quot;.</span><br></pre></td></tr></table></figure>

<p>规则 3 的情况似乎覆盖了规则 1 和规则 2，为什么规则 1 和规则 2 需要单独表述？ （TODO:）</p>
<p>如果有人知道这个问题或者有兴趣交流，可以联系<a href="/about">我</a>。</p>
<h2 id="eval-arguments"><a href="#eval-arguments" class="headerlink" title="eval/arguments"></a>eval/arguments</h2><p>非严格模式下关键字 eval/arguments 可以作为合法标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">eval</span>)</span><br></pre></td></tr></table></figure>

<p>严格模式下不 eval/arguments 虽然不是保留字，但是也不允许作为绑定标识符，也就是不能作为变量名、函数名、类型名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eval</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但是作为其他类型标识符是合法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标签标识符 引用标识符</span></span><br><span class="line"><span class="attr">eval</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">eval</span>)</span><br></pre></td></tr></table></figure>

<p>arguments 关键字的情况类似。</p>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p><code>true</code>、<code>false</code>、<code>null</code>是保留字，不能作为标识符。<code>undefined</code>的情况比较特殊，它是一个合法标识符。Javascript 引擎初始化时在全局对象上初始化了名称为<code>undefined</code>的属性，值也是<code>undefined</code>。所以全局环境可以直接使用<code>undefined</code>变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>全局环境的<code>undefined</code>属性是不能重新<strong>赋值</strong>的，属性配置<code>configurable: false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> originalValue = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局undefined赋值不生效</span></span><br><span class="line"><span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalValue)</span><br><span class="line"><span class="comment">// undefined 值没有变化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>但是可以重新定义的方式来覆盖全局<code>undefined</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> originalValue = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新定义</span></span><br><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalValue)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>如果是在函数内部的局部变量<code>undefined</code>就可以正常修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalUndefined = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">localUndefinedIsMutable</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="literal">undefined</span> = globalUndefined</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> originalValue = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 局部变量undefined赋值生效</span></span><br><span class="line">  <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(originalValue)</span><br><span class="line">  <span class="comment">// 1 值发生变化</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">localUndefinedIsMutable</span>()</span><br></pre></td></tr></table></figure>

<p>由于存在上述的情况，所以代码中直接引用<code>undefined</code>变量时得到的值不一定是<code>undefined</code>。为了保证拿到<code>undefined</code>值，常见用方式是使用 <a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-void-operator">void 表达式</a>，<code>void expr</code>对表达式 expr 进行求值，然后返回<code>undefined</code>值，expr 可能包含副作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let 在<strong>非严格模式</strong>下不是保留字，因此下面的形式是正确的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">let</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="keyword">let</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">let</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;let: &#x27;</span>, <span class="keyword">let</span>)</span><br></pre></td></tr></table></figure>

<p>但是<a href="https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-let-and-const-declarations-static-semantics-early-errors">LexicalDeclaration</a>语句和<a href="https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-for-in-and-for-of-statements-static-semantics-early-errors">ForInOfStatement</a>中有更多要求，不允许<code>let</code>作为绑定名称（<a href="https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-boundnames">BoundNames</a>）。</p>
<p>下面代码中名为<code>let</code>变量的声明都是非法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError: let is disallowed as a lexically bound name</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">let</span> <span class="keyword">in</span> &#123;&#125;) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">let</span> <span class="keyword">in</span> &#123;&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">let</span> <span class="keyword">of</span> []) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">let</span> <span class="keyword">of</span> []) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> <span class="keyword">let</span> <span class="keyword">of</span> []) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> <span class="keyword">let</span> <span class="keyword">of</span> []) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>严格模式下声明名称为<code>let</code>的变量同样报错，但是注意报错原因和非严格模式不相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError: Unexpected strict mode reserved word</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">let</span> <span class="keyword">in</span> &#123;&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>既然<code>let</code>有这些额外的规定，那么<code>const</code>是不是也应该同样规定不能作为绑定名称呢？</p>
<p>查看规范原文，可以看到只对 let 做了表述。</p>
<blockquote>
<p>It is a Syntax Error if the BoundNames of ForDeclaration contains “let”.</p>
</blockquote>
<p>原因在于 const 永远是保留字，不像 let 一样只在严格模式下才是保留字，所以使用 const 作为标识符属于语法错误，在语法解析时就会报错，不需要额外规定。</p>
<h2 id="PrivateIdentifier"><a href="#PrivateIdentifier" class="headerlink" title="PrivateIdentifier"></a>PrivateIdentifier</h2><p>参考<a href="https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions-static-semantics-early-errors">规范</a></p>
<h2 id="转义序列-1"><a href="#转义序列-1" class="headerlink" title="转义序列"></a>转义序列</h2><p>关键字和标识符对于转义序列的使用有差别。<strong>关键字</strong>中不允许使用转义序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let &#123;&#125; = &#123;&#125;;</span></span><br><span class="line"><span class="comment">// \u&#123;6C&#125; 是 &#x27;l&#x27; 的转译序列</span></span><br><span class="line">\u&#123;6C&#125;et &#123;&#125;  = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上面将 let 使用了转义序列表示，所以代码解析的时候\u{6C}et 被当成标识符而不是关键字，后续语法解析会报错。</p>
<p>Node 环境运行会给出如下报错信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\u&#123;6C&#125;et &#123;&#125;  = &#123;&#125;;</span><br><span class="line">         ^</span><br><span class="line">SyntaxError: Unexpected token &#x27;&#123;&#x27;</span><br></pre></td></tr></table></figure>

<p>Typescript 的解析和提示更智能，会提示关键字中不能使用转义序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Keywords cannot contain escape characters.ts(1260)</span><br></pre></td></tr></table></figure>

<p><strong>标识符</strong>中可以使用转义序列，下面两种形式都声明了名称为 let 的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var let = 1;</span><br><span class="line">var \u&#123;6C&#125;et = 1;</span><br></pre></td></tr></table></figure>

<p>标识符中不允许以转义序列的形式出现保留字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非法，语法解析阶段报错</span></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token &#x27;const&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">const</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转义形式出现也非法，静态语意报错</span></span><br><span class="line"><span class="comment">// SyntaxError: Keyword must not contain escaped characters</span></span><br><span class="line"><span class="keyword">var</span> \u&#123;<span class="number">63</span>&#125;onst = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h1><h2 id="保留字判断"><a href="#保留字判断" class="headerlink" title="保留字判断"></a>保留字判断</h2><p>判断一个名称是否为合法的保留字受到严格模式和是否作为绑定标识符两个条件影响，<a href="https://github.com/babel/babel/blob/main/packages/babel-helper-validator-identifier/src/keyword.ts">Babel</a>提供了四个相关的工具函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非严格模式下word是不是保留字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReservedWord</span>(<span class="params">word: string, inModule: boolean</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> (inModule &amp;&amp; word === <span class="string">&#x27;await&#x27;</span>) || word === <span class="string">&#x27;enum&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 严格模式下word是不是保留字，相比于非严格模式多了几个保留字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isStrictReservedWord</span>(<span class="params">word: string, inModule: boolean</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isReservedWord</span>(word, inModule) || reservedWordsStrictSet.<span class="title function_">has</span>(word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 严格模式下只针对绑定标识符形式来word说是保留字</span></span><br><span class="line"><span class="comment"> * 也就是word可以作为标识符引用、标签标识符等形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isStrictBindOnlyReservedWord</span>(<span class="params">word: string</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> reservedWordsStrictBindSet.<span class="title function_">has</span>(word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 严格模式下word是不是保留字，包括所有可能的保留字情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isStrictBindReservedWord</span>(<span class="params"></span></span><br><span class="line"><span class="params">  word: string,</span></span><br><span class="line"><span class="params">  inModule: boolean</span></span><br><span class="line"><span class="params"></span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="title function_">isStrictReservedWord</span>(word, inModule) || <span class="title function_">isStrictBindOnlyReservedWord</span>(word)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合法标识符判断"><a href="#合法标识符判断" class="headerlink" title="合法标识符判断"></a>合法标识符判断</h2><p><a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isValidIdentifier.ts">isValidIdentifier</a>判断名称 name 是否是合法标识符，reserved 为 true 表示排除保留字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">isValidIdentifier</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name: string,</span></span><br><span class="line"><span class="params">  reserved: boolean = <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span>): boolean &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name !== <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (reserved) &#123;</span><br><span class="line">    <span class="comment">// &quot;await&quot; is invalid in module, valid in script; better be safe (see #4952)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isKeyword</span>(name) || <span class="title function_">isStrictReservedWord</span>(name, <span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isIdentifierName</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isValidES3Identifier.ts">isValidES3Identifier</a>判断 name 是否是合法的 ES3 标识符，相比于<code>isValidIdentifier</code>排除了 ES3 中规定的标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">isValidES3Identifier</span>(<span class="params">name: string</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isValidIdentifier</span>(name) &amp;&amp; !<span class="variable constant_">RESERVED_WORDS_ES3_ONLY</span>.<span class="title function_">has</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换合法标识符"><a href="#转换合法标识符" class="headerlink" title="转换合法标识符"></a>转换合法标识符</h2><p><a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/converters/toIdentifier.ts">toIdentifier</a>将字符串转换为驼峰形式的合法标识符名称，排除可能的保留字形式，可能需要以<code>_</code>开头。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">toIdentifier</span>(<span class="params">input: string</span>): string &#123;</span><br><span class="line">  input = input + <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// replace all non-valid identifiers with dashes</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> input) &#123;</span><br><span class="line">    name += <span class="title function_">isIdentifierChar</span>(c.<span class="title function_">codePointAt</span>(<span class="number">0</span>)) ? c : <span class="string">&#x27;-&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove all dashes and numbers from start of name</span></span><br><span class="line">  name = name.<span class="title function_">replace</span>(<span class="regexp">/^[-0-9]+/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// camel case</span></span><br><span class="line">  name = name.<span class="title function_">replace</span>(<span class="regexp">/[-\s]+(.)?/g</span>, <span class="keyword">function</span> (<span class="params">match, c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c ? c.<span class="title function_">toUpperCase</span>() : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isValidIdentifier</span>(name)) &#123;</span><br><span class="line">    name = <span class="string">`_<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name || <span class="string">&#x27;_&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/converters/toBindingIdentifierName.ts">toBindingIdentifierName</a>将字符串转换为合法的绑定标识符名称，在<code>toIdentifier</code>的基础上再排除<code>eval</code>和<code>arguments</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">toBindingIdentifierName</span>(<span class="params">name: string</span>): string &#123;</span><br><span class="line">  name = <span class="title function_">toIdentifier</span>(name)</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;eval&#x27;</span> || name === <span class="string">&#x27;arguments&#x27;</span>) name = <span class="string">&#x27;_&#x27;</span> + name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol>
<li><p>解释这些概念 标识符名称、标识符、关键字、保留字，它们之间有什么联系和区别？</p>
</li>
<li><p>Javascript 和 C 语言在合法标识符名称形式上有什么区别？</p>
</li>
<li><p>这段代码的含义是什么，为什么可以这样写？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 求和(...数列) &#123;</span><br><span class="line">  return 数列.reduce((和, 数) =&gt; 数 + 和, 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(求和(1, 2, 3))</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码正确么，运行结果是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var \u&#123;12&#125; = 1</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码会能正确运行么，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">var \u&#123;61&#125; = 2</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码会能正确运行么，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">let \u&#123;61&#125; = 2</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码正确么，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var private = 2</span><br><span class="line">console.log(private)</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码正确么，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">var private = 2</span><br><span class="line">console.log(private)</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码运行结果如何，为什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">from</span> <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;from: &#x27;</span>, <span class="keyword">from</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码能按预期打印谁 1 么？不能的话如何修改？两个’eval’有什么区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(&#x27;use strict; var eval = 1; console.log(eval)&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>yield 和 await 什么时候可以作为标识符，什么情况下作为关键字？</p>
</li>
<li><p>这段代码正确么，为什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> \u&#123;<span class="number">63</span>&#125;onst = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>undefined 相关</p>
<ol>
<li><code>undefined</code>是关键字还是标识符？</li>
<li><code>&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;</code>为什么可以这样写？</li>
<li><code>undefined === void 0</code>的值总是<code>true</code>么？</li>
<li><code>null</code>和<code>undefined</code>有什么区别？</li>
</ol>
</li>
<li><p>如何判断名称 name 是否是保留字？</p>
</li>
<li><p>如何判断名称 name 是合法标识符？</p>
</li>
<li><p>给一个字符串 name，如何将其转换成合法的标识符。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>深入理解Javascript</category>
      </categories>
      <tags>
        <tag>Identifier</tag>
        <tag>ECMAScript</tag>
        <tag>IdentifierName</tag>
        <tag>标识符名称</tag>
        <tag>标识符</tag>
        <tag>ReservedWord</tag>
        <tag>保留字</tag>
        <tag>Keyword</tag>
        <tag>关键字</tag>
        <tag>Unicode</tag>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象语法树</title>
    <url>/2022/02/27/babel/advanced/ast/</url>
    <content><![CDATA[<p>Javascript 代码经过解析得到抽象语法树（<strong>A</strong>bstract <strong>S</strong>yntax <strong>T</strong>ree），用来表示程序源码结构。</p>
<p>前端基础工具 Babel、ESLint、Prettier 等使用的 Javascript 抽象语法树最早是火狐的工程师开发 SpiderMonkey 引擎时使用的格式，后来发展为统一的<a href="https://github.com/estree/estree">ESTree 规范</a>，包含 ECMAScript 规范各版本对应的抽象语法树文档和一些废弃或者是提案语法的文档。</p>
<p>Babel 使用的抽象语法树规范参考<a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md">官方文档</a>。抽象语法树规范主要描述每种语法特性的树节点，主要包括文件（File）、程序（Program）、语句（Statement）、声明（Declaration）、表达式（Expression）和其他杂项类型。</p>
<p>使用网站<a href="https://astexplorer.net/">astexplorer</a>可以方便的查看任意 JS 代码抽象语法树结构。左边是源码，右边是对应的抽象语法树。</p>
<p><img data-src="/images/ast-explorer.png" alt="ast-explorer"></p>
<h1 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h1><p>下面使用 Babel 为例，来看看抽象语法树节点都包含哪些具体类型。</p>
<h2 id="基础节点类型"><a href="#基础节点类型" class="headerlink" title="基础节点类型"></a>基础节点类型</h2><p><code>BaseNode</code>对象是所有的抽象语法树节点的基础类型，不同的节点在<code>BaseNode</code>对象的基础上增加字段代表独有信息。<code>BaseNode</code>对象格式如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">BaseNode</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: string;</span><br><span class="line">  <span class="attr">loc</span>: <span class="title class_">SourceLocation</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">start</span>: number | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">end</span>: number | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">leadingComments</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="title class_">Comment</span>&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">innerComments</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="title class_">Comment</span>&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">trailingComments</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="title class_">Comment</span>&gt; | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  range?: [number, number];</span><br><span class="line">  extra?: <span class="title class_">Record</span>&lt;string, unknown&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>type</code>字段是代表节点类型，不同节点根据类型字段进行区分。<code>loc</code>字段代表该节点在源码中的首尾行列位置信息，<code>start</code>和<code>end</code>代表该节点在源码中的字符下标位置，<code>range</code>字段以数组形式存储<code>[start, end]</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">SourceLocation</span> &#123;</span><br><span class="line">  <span class="attr">source</span>: string | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">start</span>: <span class="title class_">Position</span>;</span><br><span class="line">  <span class="attr">end</span>: <span class="title class_">Position</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Position</span> &#123;</span><br><span class="line">  <span class="attr">line</span>: number; <span class="comment">// &gt;= 1</span></span><br><span class="line">  <span class="attr">column</span>: number; <span class="comment">// &gt;= 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leadingComments/innerComments/trailingComments</code>是节点前后的注释信息。<code>extra</code>字段存储额外的信息，例如括号表达式标志为<code>parenthesized</code>。</p>
<h2 id="File-amp-Program-amp-Directive"><a href="#File-amp-Program-amp-Directive" class="headerlink" title="File &amp; Program &amp; Directive"></a>File &amp; Program &amp; Directive</h2><h3 id="源码类型"><a href="#源码类型" class="headerlink" title="源码类型"></a>源码类型</h3><p>JS 抽象语法树根节点都是<code>File</code>类型，代表当前整个源码文件。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">BaseNode</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;File&#x27;</span></span><br><span class="line">  <span class="attr">program</span>: <span class="title class_">Program</span></span><br><span class="line">  comments?: <span class="title class_">Array</span>&lt;<span class="title class_">CommentBlock</span> | <span class="title class_">CommentLine</span>&gt; | <span class="literal">null</span></span><br><span class="line">  tokens?: <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt; | <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>File</code>节点下包含<code>Program</code>类型节点，是代码的根节点。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Program</span> <span class="keyword">extends</span> <span class="title class_">BaseNode</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Program&#x27;</span></span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Statement</span>&gt;</span><br><span class="line">  <span class="attr">directives</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Directive</span>&gt;</span><br><span class="line">  <span class="attr">sourceType</span>: <span class="string">&#x27;script&#x27;</span> | <span class="string">&#x27;module&#x27;</span></span><br><span class="line">  interpreter?: <span class="title class_">InterpreterDirective</span> | <span class="literal">null</span></span><br><span class="line">  <span class="attr">sourceFile</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 引入模块机制之前，Javascript 的代码都是全局脚本（Script）类型。引入模块（Module）机制后为了与脚本进行区分，<code>Program</code>节点使用 <code>sourceType</code>字段表示分为脚本（Script）和模块（Module）两种。对于任意 JS 文件，如果包含导入导出（<code>import/export</code>）语句，可以确认是模块类型；如果不包含导入导出语句可能是模块类型，也可能是脚本类型。使用 Babel 解析代码时可以指定文件的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> parser <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`let a = 1;`</span></span><br><span class="line">parser.<span class="title function_">parse</span>(code, &#123; <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><code>sourceType</code>解析参数用来指定代码类型，有三个选项。</p>
<ol>
<li><code>module</code> - 指定代码是模块类型</li>
<li><code>script</code> - 指定代码是脚本类型，如果包含导入导出语句会<strong>抛出异常</strong>，默认值。</li>
<li><code>unambiguous</code> - 不指定类型，根据是否包含导入导出语句进行推测，不会抛出异常。</li>
</ol>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><code>Program</code>节点中包含<code>directives</code>字段代表<a href="https://262.ecma-international.org/6.0/#sec-directive-prologues-and-the-use-strict-directive">指令序言</a>（Directive Prologue），指全局或者函数内部最开始的若干个语句，这些语句的内容是字符串字面量的形式。这些语句合称为指令序言，其中每个语句称为指令（Directive），当前的规范中只规定了严格模式指令（Use Strict Directive）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> parser <span class="keyword">from</span> <span class="string">&#x27;@babel/parser&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = <span class="string">`&#x27;use strict&#x27;; let a = 1;`</span></span><br><span class="line"></span><br><span class="line">parser.<span class="title function_">parse</span>(script)</span><br></pre></td></tr></table></figure>

<p>指令序言中可能包含多条重复的严格模式指令，不属于语法错误，但是可以由给出警告。</p>
<p><code>Program</code>节点的<code>interpreter</code>字段是解释器指令（InterpreterDirective），用来代表 JS 文件作为 Shell 脚本命令运行时指定使用<code>node</code>作为解释器运行，这是 Unix 系统的<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">约定</a>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> parser <span class="keyword">from</span> <span class="string">&#x27;@babel/parser&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = <span class="string">`#!/usr/bin/env node &#x27;use strict&#x27;; let a = 1;`</span></span><br><span class="line"></span><br><span class="line">parser.<span class="title function_">parse</span>(script)</span><br></pre></td></tr></table></figure>

<p>注意解释器指令必须位于文件<strong>第一行</strong>，否则解析会报错。解释器指令属于 Babel 的扩展特性，不属于 ECMAScript 规范。</p>
<h2 id="语句（Statement）"><a href="#语句（Statement）" class="headerlink" title="语句（Statement）"></a>语句（Statement）</h2><p>语句是<code>Program</code>节点的子节点，常见的语句类型如下。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">// 只包含一个分号的空语句 EmptyStatement</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">// DebuggerStatement</span><br><span class="line">debugger</span><br><span class="line"></span><br><span class="line">// WithStatement</span><br><span class="line">with (a) &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 块语句 BlockStatement</span><br><span class="line">&#123;</span><br><span class="line">  let a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 流程控制语句</span><br><span class="line">return 1;</span><br><span class="line">label1: 1;</span><br><span class="line">break;</span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">// 分支语句</span><br><span class="line">if (a) &#123;&#125;</span><br><span class="line">switch (a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 异常语句</span><br><span class="line">try &#123; &#125; catch() &#123;&#125;</span><br><span class="line">throw e;</span><br><span class="line"></span><br><span class="line">// 循环语句</span><br><span class="line">while (true) &#123;&#125;</span><br><span class="line">do &#123;&#125; while (true)</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;&#125;</span><br><span class="line">for (const key in obj) &#123;&#125;</span><br><span class="line">for (const value of array) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外有两种特殊的语句，声明语句（Declaration）和表达式语句（ExpressionStatement）。表达式语句是由任意表达式组成的语句，可能的情况参考表达式类型。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>声明语句创建一个绑定标识符（Binding Identifier），包括变量（VariableDeclaration）、函数（FunctionDeclaration）、类（ClassDeclaration）、导入导出等情况。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">&#x27;math&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; math &#125;</span><br></pre></td></tr></table></figure>

<p>函数、类、导入也存在表达式的形式。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Test</span> = <span class="keyword">new</span> (<span class="keyword">class</span> &#123;&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="title function_">import</span>(<span class="string">&#x27;math&#x27;</span>).<span class="title function_">then</span>()</span><br></pre></td></tr></table></figure>

<h2 id="表达式（Expression）"><a href="#表达式（Expression）" class="headerlink" title="表达式（Expression）"></a>表达式（Expression）</h2><p>表达式类型包含了大部分抽象语法树节点类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnaryExpression</span></span><br><span class="line">!a</span><br><span class="line"><span class="comment">// BinaryExpression</span></span><br><span class="line">a + b</span><br><span class="line"><span class="comment">// LogicalExpression</span></span><br><span class="line">a &amp;&amp; b</span><br><span class="line"><span class="comment">// AssignmentExpression</span></span><br><span class="line">a = b</span><br><span class="line"><span class="comment">// ConditionalExpression</span></span><br><span class="line">a ? b : c</span><br><span class="line"><span class="comment">// MemberExpression</span></span><br><span class="line">a.<span class="property">b</span></span><br><span class="line"><span class="comment">// CallExpression</span></span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line"><span class="comment">// SequenceExpression 逗号表达式</span></span><br><span class="line">a, b</span><br><span class="line"><span class="comment">// 括号表达式</span></span><br><span class="line">!(a + b)</span><br></pre></td></tr></table></figure>

<p>另外一些特殊的表达式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">super</span>.<span class="property">a</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">a</span></span><br><span class="line"><span class="title function_">import</span>(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>普通字面量</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NumericLiteral</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">// BooleanLiteral</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="comment">// NullLiteral</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="comment">// 由StringLiteral组成的BinaryExpression</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// RegExpLiteral</span></span><br><span class="line">/[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>]+/g</span><br><span class="line"><span class="comment">// BigIntLiteral</span></span><br><span class="line"><span class="number">1n</span>;</span><br></pre></td></tr></table></figure>

<p>其中 Symbol 没有字面量形式。另外 ECMAScript 规范规定<code>undefined</code>是标识符，默认值是<code>undefined</code>，而不是字面量，这点上和<code>null</code>不同。</p>
<h2 id="模式-Pattern"><a href="#模式-Pattern" class="headerlink" title="模式 Pattern"></a>模式 Pattern</h2><p>解构语法对应的几种特殊形式<br>扩展语法不是表达式，不能独立存在，只能使用在固定的几个地方。</p>
<p>TODO: 添加指向解构语法的参考</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObjectPattern 包括 AssignmentPattern和RestElement</span></span><br><span class="line"><span class="comment">// AssignmentPattern</span></span><br><span class="line"><span class="keyword">const</span> &#123; a = <span class="number">1</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// RestElement</span></span><br><span class="line"><span class="keyword">const</span> &#123; b, ...a &#125; = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayPattern</span></span><br><span class="line"><span class="keyword">const</span> [x, y] = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// RestElement</span></span><br><span class="line"><span class="keyword">const</span> [x, ...y] = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// RestElement a</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">...a</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; ...a &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; b, ...a &#125; = &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释分类单行注释（CommentLine）和多行注释（CommentBlock）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BaseComment</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">start</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">end</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">loc</span>: <span class="title class_">SourceLocation</span></span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;CommentBlock&#x27;</span> | <span class="string">&#x27;CommentLine&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">CommentBlock</span> <span class="keyword">extends</span> <span class="title class_">BaseComment</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;CommentBlock&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">CommentLine</span> <span class="keyword">extends</span> <span class="title class_">BaseComment</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;CommentLine&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Comment</span> = <span class="title class_">CommentBlock</span> | <span class="title class_">CommentLine</span></span><br></pre></td></tr></table></figure>

<p>同一个注释节点可以由多个抽象语法树节点共享，一个节点的注释有三种位置。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// leading comment</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"><span class="comment">/* inner comment */</span> a</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// trailing comment</span></span><br></pre></td></tr></table></figure>

<p>对于函数<code>fun</code>来说有前置注释（leading comment)、内部注释（inner comment）和后置（trailing comment）注释。<code>fun</code>的内部注释对于参数<code>a</code>来说是前置注释。顶层的注释也会包含在<code>Program</code>节点的<code>comments</code>数组属性中。</p>
<h2 id="节点别名-Aliases"><a href="#节点别名-Aliases" class="headerlink" title="节点别名 Aliases"></a>节点别名 Aliases</h2><p>上述节点都是具体的节点类型，若干不同节点还可以使用别名归类到同一个概念下。</p>
<h3 id="Binary"><a href="#Binary" class="headerlink" title="Binary"></a>Binary</h3><p>二元表达式（BinaryExpression）和逻辑表达式（LogicalExpression）都是两个操作数，可以使用 Binary 来引用。</p>
<h3 id="循环相关"><a href="#循环相关" class="headerlink" title="循环相关"></a>循环相关</h3><p>For 循环语句包括普通 for 语句、for-in 语句和 for-of 语句，可以统称为 For；While 语句和 Do-While 语句可以统称为 While；For 和 While 又可以统称为 Loop。</p>
<h3 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h3><p>所有可能代表函数的类型，统称为 Function。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Function</span> =</span><br><span class="line">  | <span class="title class_">FunctionDeclaration</span></span><br><span class="line">  | <span class="title class_">FunctionExpression</span></span><br><span class="line">  | <span class="title class_">ObjectMethod</span></span><br><span class="line">  | <span class="title class_">ArrowFunctionExpression</span></span><br><span class="line">  | <span class="title class_">ClassMethod</span></span><br><span class="line">  | <span class="title class_">ClassPrivateMethod</span></span><br></pre></td></tr></table></figure>

<h3 id="左值类型"><a href="#左值类型" class="headerlink" title="左值类型"></a>左值类型</h3><p>左值类型 LVal 指的是能够出现在赋值表达式左边的节点类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">LVal</span> =</span><br><span class="line">  | <span class="title class_">Identifier</span></span><br><span class="line">  | <span class="title class_">MemberExpression</span></span><br><span class="line">  | <span class="title class_">RestElement</span></span><br><span class="line">  | <span class="title class_">AssignmentPattern</span></span><br><span class="line">  | <span class="title class_">ArrayPattern</span></span><br><span class="line">  | <span class="title class_">ObjectPattern</span></span><br><span class="line">  | <span class="title class_">TSParameterProperty</span></span><br></pre></td></tr></table></figure>

<h3 id="模式类似"><a href="#模式类似" class="headerlink" title="模式类似"></a>模式类似</h3><p>可能作为 Pattern 的几种类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">PatternLike</span> =</span><br><span class="line">  | <span class="title class_">Identifier</span></span><br><span class="line">  | <span class="title class_">RestElement</span></span><br><span class="line">  | <span class="title class_">AssignmentPattern</span></span><br><span class="line">  | <span class="title class_">ArrayPattern</span></span><br><span class="line">  | <span class="title class_">ObjectPattern</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域相关"><a href="#作用域相关" class="headerlink" title="作用域相关"></a>作用域相关</h3><p>作用域相关的节点别名有 Scopable/BlockParent/Block 等，详细机制可以参考<a href="./plugin-scope.md">插件作用域篇</a>。</p>
<h1 id="AST-相关的工具"><a href="#AST-相关的工具" class="headerlink" title="AST 相关的工具"></a>AST 相关的工具</h1><p>@babel/types 包为操作 AST 节点提供了很多辅助函数，涵盖了绝大部分使用场景。对于常见的操作可以先查看下官方是否已经提供，下面列出一些常见的工具函数。</p>
<h2 id="构造-AST"><a href="#构造-AST" class="headerlink" title="构造 AST"></a>构造 AST</h2><p>每个节点在@babel/type 中都定义有相关的构造函数，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 + 2</span></span><br><span class="line">t.<span class="title function_">binaryExpression</span>(<span class="string">&#x27;+&#x27;</span>, t.<span class="title function_">numericLiteral</span>(<span class="number">1</span>), t.<span class="title function_">numericLiteral</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h2 id="查询验证节点类型"><a href="#查询验证节点类型" class="headerlink" title="查询验证节点类型"></a>查询验证节点类型</h2><p>每个节点类型都有<code>is</code>开头的辅助函数判断指定节点参数是否是某种类型的节点，可以接受第二个可选参数指定需要满足的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否</span></span><br><span class="line">t.<span class="title function_">isBinaryExpression</span>(maybeBinaryExpressionNode, &#123; <span class="attr">operator</span>: <span class="string">&#x27;*&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><code>assert</code>开头的辅助函数保证节点必须是指定类型，否则会抛出异常。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保证节点类型</span></span><br><span class="line">t.<span class="title function_">assertBinaryExpression</span>(maybeBinaryExpressionNode, &#123; <span class="attr">operator</span>: <span class="string">&#x27;*&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="多层节点"><a href="#多层节点" class="headerlink" title="多层节点"></a>多层节点</h2><p>TODO: looksLike</p>
<h2 id="从模板构造-AST"><a href="#从模板构造-AST" class="headerlink" title="从模板构造 AST"></a>从模板构造 AST</h2><p>手工构造复杂的 AST 节点树比较麻烦， <code>@babel/template</code>提供了从模板字符串自动生成对应 AST 树的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> template <span class="keyword">from</span> <span class="string">&#x27;@babel/template&#x27;</span></span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">&#x27;@babel/generator&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildRequire = <span class="title function_">template</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  var %%importName%% = require(%%source%%);</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = <span class="title function_">buildRequire</span>(&#123;</span><br><span class="line">  <span class="attr">importName</span>: t.<span class="title function_">identifier</span>(<span class="string">&#x27;myModule&#x27;</span>),</span><br><span class="line">  <span class="attr">source</span>: t.<span class="title function_">stringLiteral</span>(<span class="string">&#x27;my-module&#x27;</span>),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generate</span>(ast).<span class="property">code</span>)</span><br></pre></td></tr></table></figure>

<h2 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h2><p>抽象语法树中每个节点都是唯一的，不能在多个位置重复使用一个节点，对于需要使用两个内容一模一样的节点，可以使用辅助函数进行克隆。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> id = t.<span class="title function_">identifier</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> clonedId = t.<span class="title function_">clone</span>(id)</span><br><span class="line"></span><br><span class="line">id !== clonedId</span><br></pre></td></tr></table></figure>

<h2 id="成员表达式组合"><a href="#成员表达式组合" class="headerlink" title="成员表达式组合"></a>成员表达式组合</h2><p>成员表达式（MemberExpression）可以多个组合起来。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.b</span></span><br><span class="line"><span class="keyword">const</span> m = t.<span class="title function_">memberExpression</span>(t.<span class="title function_">identifier</span>(<span class="string">&#x27;a&#x27;</span>), t.<span class="title function_">identifier</span>(<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> c = t.<span class="title function_">identifier</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.b -&gt; a.b.c</span></span><br><span class="line">t.<span class="title function_">appendToMemberExpression</span>(m, c)</span><br><span class="line"><span class="comment">// a.b -&gt; c.a.b</span></span><br><span class="line">t.<span class="title function_">prependToMemberExpression</span>(m, c)</span><br></pre></td></tr></table></figure>

<h2 id="注释节点"><a href="#注释节点" class="headerlink" title="注释节点"></a>注释节点</h2><p>辅助函数提供了对节点添加、继承、删除注释的操作。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node = t.<span class="title function_">identifier</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加单条注释，可以指明是单行还是多行形式</span></span><br><span class="line">t.<span class="title function_">addComment</span>(node, <span class="string">&#x27;leading&#x27;</span>, <span class="string">&#x27;comment content&#x27;</span>, <span class="string">&#x27;line&#x27;</span>)</span><br><span class="line"><span class="comment">// 添加多条注释</span></span><br><span class="line">t.<span class="title function_">addComments</span>(node, <span class="string">&#x27;leading&#x27;</span>, comments)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子节点node继承父节点parent的所有注释</span></span><br><span class="line">t.<span class="title function_">inheritComments</span>(node, parent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点所有注释</span></span><br><span class="line">t.<span class="title function_">removeComments</span>(node)</span><br></pre></td></tr></table></figure>

<h2 id="值转换为-AST-节点"><a href="#值转换为-AST-节点" class="headerlink" title="值转换为 AST 节点"></a>值转换为 AST 节点</h2><p>使用<code>valueToNode</code>将具体类型未知的运行时值转换为合适的 AST 节点。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line">t.<span class="title function_">isNodesEquivalent</span>(t.<span class="title function_">valueToNode</span>(<span class="number">1</span>), t.<span class="title function_">numericLiteral</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FrontEnd</category>
        <category>Babel</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>AST</tag>
        <tag>Parsing</tag>
      </tags>
  </entry>
</search>
