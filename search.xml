<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>解构与展开</title>
    <url>/2022/03/06/js/destructuring-spread/</url>
    <content><![CDATA[<p>ES6 开始引入了解构和展开的语法特性，使用起来非常方便。但是这些特性的用法还是非常丰富的，可能多数人平常并不太会注意到，本文对其进行了完整的剖析，以作参考。</p>
<p>如果你对相关内容非常熟悉，不妨直接跳到<a href="#quiz">习题部分</a>，测试一下自己的理解，或者你可以在阅读完本文之后使用习题作为回顾。</p>
<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><h2 id="为什么引入解构"><a href="#为什么引入解构" class="headerlink" title="为什么引入解构"></a>为什么引入解构</h2><p>ES6 之前从对象或者数组中提取多个字段的话只能使用多个赋值语句，写法存在重复。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Jackie&#x27;</span></span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Chen&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多次赋值写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = person.<span class="property">firstName</span>, lastName = person.<span class="property">lastName</span>;</span><br></pre></td></tr></table></figure>

<p>使用和对象字面量一致的形式从目标值中一次提取多个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构语法</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = person</span><br></pre></td></tr></table></figure>

<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>解构对象值<code>person</code>，用对象属性<code>firstName</code>的值定义指定名称<code>fn</code>的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">firstName</span>: fn, <span class="attr">lastName</span>: ln &#125; = person</span><br></pre></td></tr></table></figure>

<p>对象属性名称和指定变量名称相同时可以使用简写形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = person</span><br></pre></td></tr></table></figure>

<p>对象解构的写法和对象字面量形式相同，因此也可以使用数字、字符串和计算属性形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用字符串</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="string">&#x27;fizz-buzz&#x27;</span>: fizzBuzz &#125; = &#123; <span class="string">&#x27;fizz-buzz&#x27;</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="number">2</span>: fizzBuzz &#125; = [<span class="literal">undefined</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;fizz-buzz&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; [key]: fizzBuzz &#125; = &#123; <span class="string">&#x27;fizz-buzz&#x27;</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>解构对象的目标值是<code>null/undefined</code>时会报错，因为对象解构要求目标值可以转换为对象<a href="https://262.ecma-international.org/6.0/#sec-requireobjectcoercible">RequireObjectCoercible</a>，Javascript 中除了<code>null/undefined</code>其他值都可以转换为对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 运行时报错 Uncaught TypeError: Cannot destructure property &#x27;a&#x27; of &#x27;null&#x27; as it is null.</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName &#125; = person</span><br></pre></td></tr></table></figure>

<p>使用解构对象形式获取数组中指定下标的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="number">2</span>: c &#125; = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>基础类型值也可以使用对象解构，获取字符串的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; length &#125; = <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>使用数组字面值类似的写法可以解构数组中元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> date = [<span class="string">&#x27;1970&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;01&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [year, month, day] = date</span><br></pre></td></tr></table></figure>

<p>使用单独的逗号可以<strong>跳过</strong>数组中的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> date = [<span class="string">&#x27;1970&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;01&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过元素 month</span></span><br><span class="line"><span class="keyword">const</span> [year, , day] = date</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用在开头，跳过year</span></span><br><span class="line"><span class="keyword">const</span> [, month, day] = date</span><br></pre></td></tr></table></figure>

<p>使用数组解构交换（swap）两个变量，不需要临时变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span></span><br><span class="line">;[x, y] = [y, x]</span><br></pre></td></tr></table></figure>

<p>或者交换已有数组中两个元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">;[arr[<span class="number">2</span>], arr[<span class="number">1</span>]] = [arr[<span class="number">1</span>], arr[<span class="number">2</span>]]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [1,3,2]</span></span><br></pre></td></tr></table></figure>

<p>数组解构的目标值必须是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable_examples">Iterable</a>，实现了迭代器协议<a href="https://262.ecma-international.org/6.0/#sec-getiterator">GetIterator</a>，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeError: &#123;&#125; is not iterable</span></span><br><span class="line"><span class="keyword">const</span> [year, month] = &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h2><p>对象解构支持嵌套形式，可以在同一处解构不同层次的多个属性。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> note = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;My first note&#x27;</span>,</span><br><span class="line">  <span class="attr">date</span>: <span class="string">&#x27;01/01/1970&#x27;</span>,</span><br><span class="line">  <span class="attr">author</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Sherlock&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Holmes&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  id,</span><br><span class="line">  title,</span><br><span class="line">  date,</span><br><span class="line">  <span class="attr">author</span>: &#123; firstName, lastName &#125;,</span><br><span class="line">&#125; = note</span><br></pre></td></tr></table></figure>

<p>注意上边的解构中定义了五个变量，不包括<code>author</code>，嵌套的形式中对应属性名不属于解构变量。如果想同时解构声明<code>author</code>变量的话，使用下面的形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// 定义变量 author</span></span><br><span class="line">  author,</span><br><span class="line">  <span class="comment">// 定义变量 firstName/lastName</span></span><br><span class="line">  <span class="attr">author</span>: &#123; firstName, lastName &#125;,</span><br><span class="line">&#125; = note</span><br></pre></td></tr></table></figure>

<p>数组解构也支持嵌套形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套数组</span></span><br><span class="line"><span class="keyword">const</span> [one, two, [three, four], five] = nestedArray</span><br></pre></td></tr></table></figure>

<p>对象解构和数组解构可以任意形式嵌套。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> note = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;My first note&#x27;</span>,</span><br><span class="line">  <span class="attr">author</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Sherlock&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Holmes&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">tags</span>: [<span class="string">&#x27;personal&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>, <span class="string">&#x27;investigations&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  title,</span><br><span class="line">  <span class="attr">author</span>: &#123; firstName &#125;,</span><br><span class="line">  <span class="attr">tags</span>: [personalTag, writingTag],</span><br><span class="line">&#125; = note</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date)</span><br></pre></td></tr></table></figure>

<p>一个比较特殊的用法是数组解构的其余元素位置可以直接再次使用对象解构形式，这样的语法设计也能够立即，数组其余元素收集得到值是数组类型，数组也是对象，也可以使用对象解构形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a = [2, 3]</span></span><br><span class="line"><span class="keyword">const</span> [, ...a] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// length:  2</span></span><br><span class="line"><span class="keyword">const</span> [, ...&#123; length &#125;] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>反过来则不成立，对象解构的其余属性位置不能嵌套使用数组解构形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syntax error</span></span><br><span class="line"><span class="keyword">let</span> &#123; ...[ ] &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="未匹配模式"><a href="#未匹配模式" class="headerlink" title="未匹配模式"></a>未匹配模式</h2><p>对象和数组解构形式中不存在匹配的元素或者属性时，解构得到的变量值为<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b === undefined</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b === undefined</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>使用等号指定解构变量的默认值，默认值在解构得到<code>undefined</code>时生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b === 2</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b = <span class="number">2</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时使用修改名称和默认值语法</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">prop</span>: p = <span class="number">123</span> &#125; = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b === 2</span></span><br><span class="line"><span class="keyword">var</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="其余元素-x2F-属性（Rest-Element-x2F-Property）"><a href="#其余元素-x2F-属性（Rest-Element-x2F-Property）" class="headerlink" title="其余元素&#x2F;属性（Rest Element&#x2F;Property）"></a>其余元素&#x2F;属性（Rest Element&#x2F;Property）</h2><p>对象解构中可以使用<code>...rest</code>形式将未指定的属性统一收集到<code>rest</code>变量代表的对象中，称为对象的其余属性（Rest Property）。对象解构中只能有一个其余属性，位置必须是最后一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; a, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxError: Rest element must be last element</span></span><br><span class="line"><span class="keyword">var</span> &#123; ..<span class="property">rest</span>, a &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxError: Rest element must be last element 指y</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...y, ...z &#125; = obj;</span><br></pre></td></tr></table></figure>

<p>数组解构中可以使用<code>...rest</code>形式将未指定的数组元素统一收集到<code>rest</code>变量代表的数组中，称为数组的其余元素（Rest Element）。数组解构中只能有一个其余元素（Rest Element），必须是最后一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxError: Rest element must be last element</span></span><br><span class="line"><span class="keyword">var</span> [...rest, a] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>对于多层嵌套的解构形式，可以在每一层都使用一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123; a, ...rest1 &#125;,</span><br><span class="line">  ...rest2</span><br><span class="line">&#125; = obj</span><br></pre></td></tr></table></figure>

<p>其余元素只能对<strong>对象本身</strong>的未被指定的<strong>可枚举属性</strong>进行收集，不包括不可枚举属性和原型对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prototype = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(prototype, &#123;</span><br><span class="line">  <span class="comment">// 只收集 b</span></span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; ...prop &#125; = obj</span><br><span class="line"><span class="comment">// prop: &#123; b: 2 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prop: &#x27;</span>, prop)</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数参数的传递与数组解构处理类似，可以使用其余参数形式（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">RestParameters</a>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">«pattern1», «pattern2»</span>) &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [«pattern1», «pattern2»] = args;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>函数定义中参数可以使用对象解构形式，来实现命名参数（Named Parameter）的效果。命名参数的好处在于参数顺序不影响结果，含义更加清晰，结合参数默认值使用更加灵活。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drawChart</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  size = <span class="string">&#x27;big&#x27;</span>,</span></span><br><span class="line"><span class="params">  coords = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;,</span></span><br><span class="line"><span class="params">  radius = <span class="number">25</span>,</span></span><br><span class="line"><span class="params">&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(size, coords, radius)</span><br><span class="line">  <span class="comment">// do some chart drawing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">drawChart</span>()</span><br><span class="line"><span class="title function_">drawChart</span>(&#123; <span class="attr">size</span>: <span class="string">&#x27;small&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><code>forEach</code></h3><p>数组的<code>forEach</code>函数也是一个典型的使用场景。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using forEach</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(note).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>Javascript 函数只能返回一个值，但是可以返回数组或者对象包含多个值，配合解构语法可以方便的拿到单个数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mousePosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [x, y] = <span class="title function_">mousePosition</span>()</span><br></pre></td></tr></table></figure>

<h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><p>正则表达式匹配返回类数组对象，配合数组解构使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseProtocol</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> parsedURL = <span class="regexp">/^(\w+)\:\/\/([^\/]+)\/(.*)$/</span>.<span class="title function_">exec</span>(url)</span><br><span class="line">  <span class="keyword">if</span> (!parsedURL) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(parsedURL)</span><br><span class="line">  <span class="comment">// [&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;,</span></span><br><span class="line">  <span class="comment">// &quot;https&quot;, &quot;developer.mozilla.org&quot;, &quot;en-US/docs/Web/JavaScript&quot;]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [, protocol, fullhost, fullpath] = parsedURL</span><br><span class="line">  <span class="keyword">return</span> protocol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其余元素"><a href="#其余元素" class="headerlink" title="其余元素"></a>其余元素</h3><p>函数参数和数组解构语法形式一样可以组合使用其余元素和对象解构语法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">...&#123; length &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for loop destructuring binding</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(note)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for loop destructuring assignment</span></span><br><span class="line"><span class="keyword">for</span> ([a, b] <span class="keyword">of</span> [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">]) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Catch-语句"><a href="#Catch-语句" class="headerlink" title="Catch 语句"></a>Catch 语句</h2><p>try 语句的 Catch 分支中也可以定义变量或者使用解构形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (&#123; message &#125;) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解构绑定与赋值"><a href="#解构绑定与赋值" class="headerlink" title="解构绑定与赋值"></a>解构绑定与赋值</h2><p>解构语法分为<a href="https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-destructuring-binding-patterns">解构绑定模式（Destructuring Binding Patterns）</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值（Destructuring Assignment）</a>两大类，二者的写法基本一致，但语义有所不同。解构绑定模式会<strong>声明新变量</strong>，也就是创建标识符绑定（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-BindingIdentifier">Binding Identifier</a>）；解构赋值会对已有的变量进行<strong>赋值</strong>。</p>
<h3 id="解构绑定"><a href="#解构绑定" class="headerlink" title="解构绑定"></a>解构绑定</h3><p>解构绑定模式用来定义变量，可能出现变量声明、for 循环语句、函数参数等处。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量声明语句 VariableDeclarator</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = person</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-of 语句也可以包含变量声明</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> &#123; firstName, lastName &#125; <span class="keyword">of</span> persons) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义参数部分，为函数声明局部变量，机制和变量声明语句类似</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">&#123; firstName, lastName &#125;</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>解构绑定模式定义了变量，所以也遵循变量声明的规则，重复声明变量属于语法错误。</p>
<p>例如在一个解构绑定中声明多个同名变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Jackie&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Chen&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier &#x27;firstName&#x27; has already been declared</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName, firstName &#125; = person</span><br></pre></td></tr></table></figure>

<p>或者在解构绑定中声明已经存在的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Jackie&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Chen&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstName</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier &#x27;firstName&#x27; has already been declared</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName &#125; = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>另外解构绑定是从目标值中提取属性来声明变量，缺少目标值的话也属于语法错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Uncaught SyntaxError: Missing initializer in destructuring declaration</span></span><br><span class="line"><span class="keyword">let</span> &#123; firstName, lastName &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构赋值是表达式，可以出现在任意赋值语句的左侧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName,</span><br><span class="line">  lastName</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值语句 AssignmentExpression</span></span><br><span class="line">;(&#123; firstName, lastName &#125; = person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-of 语句也可以使用赋值形式</span></span><br><span class="line"><span class="keyword">for</span> (&#123; firstName, lastName &#125; <span class="keyword">of</span> persons) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里解构赋值语句需要用括号对包裹起来，形成表达式语句，花括号对开头的语句会被识别为块语句而不是解构赋值表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构赋值形式的语法陷阱，直接使用花括号对会被识别为块语句，可以使用括号对包裹，强制为表达式</span></span><br><span class="line"><span class="keyword">let</span> prop</span><br><span class="line">assert.<span class="title function_">throws</span>(<span class="function">() =&gt;</span> <span class="built_in">eval</span>(<span class="string">&quot;&#123;prop&#125; = &#123; prop: &#x27;hello&#x27; &#125;;&quot;</span>), &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;SyntaxError&#x27;</span>,</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&quot;Unexpected token &#x27;=&#x27;&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>eval</code>函数，因为这属于编译期语法错误，无法正常的直接运行，<code>eval</code>将编译期错误转换为运行时错误，配合测试代码正常运行。</p>
<p>解构绑定中要求名称不能出现重复，属于变量定义本身的语法要求。解构赋值不要求名称唯一，可以出现重复。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">;[a = <span class="number">2</span>, a = <span class="number">3</span>] = [a]</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure>

<p>但是赋值语义要求赋值表达式左侧的形式必须是左值表达式（LeftHandSideExpression），而且是合法的赋值目标。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">[a, a.<span class="property">b</span>] = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a()是左值表达式，但不是合法赋值目标</span></span><br><span class="line">[ <span class="title function_">a</span>() ] = [<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="语法差异"><a href="#语法差异" class="headerlink" title="语法差异"></a>语法差异</h3><p>解构绑定语法和解构赋值语法除了使用的位置不同，其本身都支持对象解构、数组解构、默认值、其余元素属性、嵌套支持等特性，二者的语法定义是非常类似的。</p>
<p>差别在于解构绑定的语义是定义变量，所以递归语法定义的出口是绑定标识符（Binding Identifier），因为变量的定义是用某个值来初始化某个名字。但是解构赋值的语义是把某个值赋值给某个左值（LeftHandSideExpression），标识符代表的变量只是左值的一种形式，还有成员表达式等很多表达式都是合法的左值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.b是一个左值，所以可以使用在解构赋值形式中</span></span><br><span class="line">;[a.<span class="property">b</span>] = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a: &#x27;</span>, a)</span><br></pre></td></tr></table></figure>

<p>左值形式使用在解构绑定形式中是错误的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syntax error</span></span><br><span class="line"><span class="keyword">const</span> [a.<span class="property">b</span>] = [<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<h1 id="展开语法（Spread-Syntax）"><a href="#展开语法（Spread-Syntax）" class="headerlink" title="展开语法（Spread Syntax）"></a>展开语法（Spread Syntax）</h1><p>展开语法和解构中的其余元素都使用<code>...</code>的形式，二者都是特殊语法形式，不是表达式。其余元素是将多个属性或者值收集到一个值中，展开语法正好相反。</p>
<p>展开语法在同一个表达式中可以使用多次，而且不要求在最后一个，而且只能出现在三个固定的语法解构中。</p>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>用在对象初始化表达式（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-object-initializer">Object Initializer</a>）中方便地拷贝对象、扩展对象、合并两个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明式</span></span><br><span class="line"><span class="keyword">let</span> newObj = &#123; a, ...b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令式 等价形式</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(a, b)</span><br></pre></td></tr></table></figure>

<h3 id="与Object-assign的异同"><a href="#与Object-assign的异同" class="headerlink" title="与Object.assign的异同"></a>与<code>Object.assign</code>的异同</h3><p>目标对象被展开或者使用<code>Object.assign</code>创建新对象时，二者都使用<a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-get-o-p">Get</a>操作来获取对象属性值，因此定义了 get 属性的对象得到的结果是 get 属性求值结果而不是 get 属性本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo: 123 &#125;</span></span><br><span class="line"><span class="keyword">const</span> spread = &#123; ...original &#125;</span><br><span class="line"><span class="comment">// &#123; foo: 123 &#125;</span></span><br><span class="line"><span class="keyword">const</span> assign = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, original)</span><br></pre></td></tr></table></figure>

<p>展开语法和<code>Object.assign</code>都值处理对象的可枚举属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">    <span class="attr">inheritedEnumerable</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto, &#123;</span><br><span class="line">    <span class="attr">ownEnumerable</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ownNonEnumerable</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; ownEnumerable: 2 &#125;</span></span><br><span class="line">&#123;...obj&#125;</span><br><span class="line"><span class="comment">// &#123; ownEnumerable: 2 &#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br></pre></td></tr></table></figure>

<p>展开语法和<code>Object.assign</code>语意上的差别在于展开语法使用<a href="https://262.ecma-international.org/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc">Define</a>语义定义属性，<code>Object.assign</code>使用<a href="https://262.ecma-international.org/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver">Set</a>语义设置属性，二者的区别可以参考<a href="https://2ality.com/2016/10/rest-spread-properties.html#spreading-objects-versus-object.assign()">Spreading objects versus Object.assign()</a>。</p>
<h3 id="属性顺序问题"><a href="#属性顺序问题" class="headerlink" title="属性顺序问题"></a>属性顺序问题</h3><p>对象初始化中可以出现多个展开，因此先后顺序有影响，后展开的属性会覆盖之前同名的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span>, <span class="attr">baz</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo: true, bar: 2, baz: 3 &#125;</span></span><br><span class="line">&#123;...obj, <span class="attr">foo</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo: true, bar: 2, baz: 3 &#125;</span></span><br><span class="line">&#123;<span class="attr">foo</span>: <span class="literal">true</span>, ...obj&#125;</span><br></pre></td></tr></table></figure>

<p>即使多个展开之间不存在同名属性情况，对象本身也记录了属性的顺序，字符串属性是按照<strong>插入顺序</strong>（Insertion Order）存储的，<code>for-in</code>属性遍历和<code>Object.keys</code>遵循相同的顺序。</p>
<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>用在数组初始化表达式（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-array-initializer">Array Initializer</a>）中创建新的数组，比使用<code>concat/push/shift</code>等函数创建新数组更方便。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [a, ...b, c, ...d]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开字符串</span></span><br><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stringArray = [...string]</span><br></pre></td></tr></table></figure>

<h2 id="实参列表"><a href="#实参列表" class="headerlink" title="实参列表"></a>实参列表</h2><p>用在函数调用表达式的参数列表（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-argumentlistevaluation">Argument List Evaluation</a>）中，可以替换<code>apply</code>函数的使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用位置</span></span><br><span class="line"><span class="title function_">multiply</span>(...a)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="title function_">multiply</span>(...numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价形式</span></span><br><span class="line">multiply.<span class="title function_">apply</span>(<span class="literal">null</span>, numbers)</span><br></pre></td></tr></table></figure>

<p>对于构造函数调用无法使用<code>apply</code>函数，只能使用展开语法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dateFields = [<span class="number">1970</span>, <span class="number">0</span>, <span class="number">1</span>] <span class="comment">// 1 Jan 1970</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(...dateFields)</span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>使用扩展语法进行对象拷贝是浅拷贝，和使用<code>Object.assign</code>的效果相同。如果存在多层嵌套的对象或者数组，嵌套的属性或者元素是多个拷贝共享的，这可能造成预期之外的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line"><span class="keyword">let</span> b = [...a]</span><br><span class="line"></span><br><span class="line">b.<span class="title function_">shift</span>().<span class="title function_">shift</span>()</span><br><span class="line"><span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Oh no!  Now array &#x27;a&#x27; is affected as well:</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">//  [[], [2], [3]]</span></span><br></pre></td></tr></table></figure>

<h2 id="可展开对象"><a href="#可展开对象" class="headerlink" title="可展开对象"></a>可展开对象</h2><p>对象扩展语法中 null 和 undefined 被忽略而不是报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;...<span class="literal">undefined</span>&#125;</span><br><span class="line">&#123;...<span class="literal">null</span>&#125;</span><br><span class="line">&#123;...<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的展开元素要求被展开的值是 Iterable，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">key1</span>: <span class="string">&#x27;value1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> array = [...obj] <span class="comment">// TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure>

<h1 id="规范解读"><a href="#规范解读" class="headerlink" title="规范解读"></a>规范解读</h1><h2 id="解构绑定模式"><a href="#解构绑定模式" class="headerlink" title="解构绑定模式"></a>解构绑定模式</h2><p>解构绑定的语法分别定义在变量声明、函数参数、<code>for-in</code>语句、<code>catch</code>语句等可以使用的语法位置，参考变量定义语句处的语法定义（<a href="https://tc39.es/ecma262/#sec-destructuring-binding-patterns">Destructuring Binding Patterns</a>）即可。</p>
<h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>绑定模式（BindingPattern）的分为对象绑定（ObjectBindingPattern）和数组绑定模式（ArrayBindingPattern）两种。</p>
<p>对象绑定模式中包括属性列表（BindingPropertyList）和其余属性（BindingRestProperty），属性列表由若干个单独的属性（BindingProperty）组成。单个属性有单名称绑定（SingleNameBinding）和键值对（PropertyName: BindingElement）的形式。其中绑定元素（BindingElement）和数组绑定语法使用的形式，这个定义使得对象绑定能够<strong>嵌套</strong>数组绑定形式。</p>
<p>数组绑定中包含绑定元素列表（BindingElementList）、可忽略元素（Elision）和其余元素（RestBindingElement）。</p>
<ol>
<li>绑定元素列表有若干个绑定元素组成，绑定元素包括单名称绑定（SingleNameBinding）和绑定模式（BidingPattern Initializer）形式，这里的<strong>嵌套定义</strong>使得数组绑定可以嵌套使用数组或者对象绑定形式。</li>
<li>可忽略元素代表单个逗号，表示忽略数组中的某个元素。</li>
<li>其余元素绑定有两种形式，绑定标识符（…BindingIdentifier）和绑定模式（…BindingPattern），这里的嵌套定义又使得其余元素可以嵌套的使用任意的绑定模式。</li>
</ol>
<h3 id="递归求值"><a href="#递归求值" class="headerlink" title="递归求值"></a>递归求值</h3><p>绑定的求值过程和绑定模式的定义解构对应，都是递归形式，整个求值过程就是递归的找到对应的对象属性或者数组元素，进行求值，然后使用名称和值的对在当前的语法环境（EnvironmentRecord）中定义变量。</p>
<p>绑定初始化（<a href="https://tc39.es/ecma262/#sec-runtime-semantics-bindinginitialization">BindingInitialization</a>）代表了绑定模式的整个初始化过程。首先会将绑定目标值转换为对象（RequireObjectCoercible），不能转换为对象的值会在运行时报错。属性绑定初始化（<a href="https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization">PropertyBindingInitialization</a>）对应绑定属性列表的初始化，然后进入到单个属性的初始化过程（<a href="https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization">KeyedBindingInitialization</a>）。<a href="https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization">RestBindingInitialization</a> 处理对象其余属性的绑定，首先创建一个全新的对象，然后使用（<a href="https://tc39.es/ecma262/#sec-copydataproperties">CopyDataProperties</a>）操作将被解构对象的<strong>可枚举属性</strong>拷贝到新的对象上，被拷贝的对象属性排除了绑定模式的绑定名称（BoundNames）语义记录的名称列表。</p>
<p>对于数组模式来说绑定初始化会进入迭代器绑定初始化（<a href="https://tc39.es/ecma262/#sec-runtime-semantics-iteratorbindinginitialization">IteratorBindingInitialization</a>）的过程。首先会从被解构的目标获取迭代器，所以不可迭代的对象运行时会报错。对于数组中的每个元素进行初始化的过程会造成迭代器向前一步，如果元素嵌套了其他绑定模式，会再次进入绑定初始化过程。数组中其余元素的绑定会创建一个新数组，然后将迭代器中的剩余元素逐个添加到新数组中。</p>
<h2 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值的语法定义和解构绑定类似，区别在于一个使用术语绑定（Binding），一个使用术语赋值（Assignment），这也是二者的运行时语义上的差别。</p>
<p>需要注意的是赋值的语义要求被赋值目标形式合法，可以参考这个问题 <a href="https://stackoverflow.com/questions/62710902/are-function-calls-with-arguments-valid-left-hand-side-expressions-according-to">Are function calls with arguments valid left-Hand-Side-Expressions according to ECMAScript</a>。</p>
<p>简单的说就是只有左值才能作为合法的赋值目标，标准中规定了 LeftHandSideExpression 来表示能够出现在赋值语句左边的形式，但是其中有些形式运行时语义上也无法正确赋值，因此有赋值目标类型的概念（ <a href="https://tc39.es/ecma262/#sec-static-semantics-assignmenttargettype">AssignmentTargetType</a>），将 LeftHandSideExpression 的所有可能类型进行划分，能够正确赋值的形式的赋值目标类型为简单（simple），不能正确赋值的形式的赋值目标类型为非法（invalid）。</p>
<h2 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h2><p>对象初始化（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-object-initializer">Object Initializer</a>）中展开语法的属性定义求值过程在属性定义求值（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-propertydefinitionevaluation">PropertyDefinitionEvaluation</a>）中，同样使用<a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-copydataproperties">CopyDataProperties</a>将被展开值的属性拷贝定义到目标对象上。</p>
<p>数组初始化语法中的展开元素（Spread Element）处理由<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-arrayaccumulation">ArrayAccumulation</a>过程规定，被展开的元素也必须满足迭代器协议，通过迭代过程将下标和元素的键值对拷贝定义到新的数组中。</p>
<p>调用表达式参数列表（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-argumentlistevaluation">Argument List Evaluation</a>）中的求值过程和数组初始化语法中类似。</p>
<h1 id="问题与练习"><a href="#问题与练习" class="headerlink" title="问题与练习 "></a>问题与练习 <span id="quiz"></span></h1><ol>
<li>对象解构的目标值是<code>null</code>或者<code>undefined</code>时会发生什么？满足什么条件的值可以数组解构？</li>
<li>对象解构中被解构对象的所有属性值都会被解构么？原型对象上的属性么会被解构么？</li>
<li>解构语法中没有匹配的属性或者元素时如何处理？</li>
<li>解构语法中什么情况下会使用指定的默认值？</li>
<li>解构绑定和解构赋值的语法有哪些相同和差异的地方？</li>
<li>解构绑定和解构赋值的运行时语义上相同么？</li>
<li>解构语法支持对象、数组以及互相嵌套的形式，但是数组语法中使用其余元素时并不对称，为什么这样设计？</li>
<li>展开语法<code>&#123;...null&#125;</code>和<code>&#123;...undefined&#125;</code>运行结果如何？</li>
<li>展开语法<code>[...null]</code>和<code>[...undefined]</code>运行结果如何？</li>
<li>展开语法会展开目标对象的所有属性么？</li>
<li>使用解构和展开语法实现对象拷贝是深拷贝还是浅拷贝？</li>
<li>展开语法不能拷贝哪些属性？</li>
<li>展开语法和<code>Object.assign</code>进行属性拷贝时有哪些相同和差异的地方？</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="解构（Destructuring）"><a href="#解构（Destructuring）" class="headerlink" title="解构（Destructuring）"></a>解构（Destructuring）</h2><p>下面几个资料介绍了解构语法的用法，其内容都包含在本文中，感兴趣可以进行阅读。</p>
<ol>
<li><a href="https://www.digitalocean.com/community/tutorials/understanding-destructuring-rest-parameters-and-spread-syntax-in-javascript">Understanding Destructuring, Rest Parameters, and Spread Syntax in JavaScript</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring Assignment</a></li>
<li><a href="https://2ality.com/2015/01/es6-destructuring.html">Destructuring and parameter handling in ECMAScript 6</a></li>
<li><a href="https://exploringjs.com/impatient-js/ch_destructuring.html">JavaScript for impatient programmers Chapter 37 Destructuring</a></li>
<li><a href="https://exploringjs.com/impatient-js/ch_callables.html#parameter-handling">JavaScript for impatient programmers Chapter 25.6 Parameter Handling</a></li>
<li><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/">ES6 In Depth: Destructuring</a></li>
<li>《Understanding ECMAScript 6》Chapter 5 Destructuring for Easier Data Access</li>
</ol>
<p><a href="https://github.com/tc39/proposal-object-rest-spread/blob/main/Rest.md">Object Rest Properties for ECMAScript</a>是对象其余属性的语法提案，已经进入正式的 ECMAScript 2018 规范中。</p>
<p>ECMAScript 规范中关于解构绑定、解构赋值、展开语法等特性的规定参考以下章节。</p>
<ol>
<li><a href="https://tc39.es/ecma262/#sec-runtime-semantics-bindinginitialization">Binding Initialization</a></li>
<li><a href="https://tc39.es/ecma262/#sec-destructuring-binding-patterns">Destructuring Binding Patterns</a></li>
<li><a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-destructuring-assignment">Destructuring Assignment</a>。</li>
<li><a href="https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-parameter-lists">Parameter List</a></li>
</ol>
<p><a href="https://eslint.org/docs/rules/prefer-destructuring">prefer-destructuring</a>是 ESLint 中关于解构的规则。</p>
<h2 id="展开（Spread）"><a href="#展开（Spread）" class="headerlink" title="展开（Spread）"></a>展开（Spread）</h2><p>展开语法的介绍可以首先参考 MDN 文档 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">Spread Syntax</a>和<a href="https://2ality.com/2016/10/rest-spread-properties.html#spreading-objects-versus-objectassign">ES2018: Rest&#x2F;Spread Properties</a>的介绍。</p>
<p>对象其余属性（Rest Property）和展开属性（Spread Property）的语法提案<a href="https://github.com/tc39/proposal-object-rest-spread">Object Rest&#x2F;Spread Properties for ECMAScript</a>，其中分别对<a href="https://github.com/tc39/proposal-object-rest-spread/blob/main/Rest.md">Rest</a>和<a href="https://github.com/tc39/proposal-object-rest-spread/blob/main/Spread.md">Spread</a>做说明，关于语法的各种使用情况的例子可以作为准确参考。</p>
<p>其余元素（Rest Element）和其余属性（Rest Property）分别对应数组解构和对象解构，可以参考解构部分的规范描述。</p>
<p>Babel 对于展开语法的转换实现在插件<a href="https://babel.dev/docs/en/babel-plugin-proposal-object-rest-spread">@babel&#x2F;plugin-proposal-object-rest-spread</a>中。</p>
]]></content>
      <categories>
        <category>深入理解Javascript</category>
      </categories>
      <tags>
        <tag>解构</tag>
        <tag>展开</tag>
        <tag>ES6</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript中字符串与编码问题</title>
    <url>/2022/02/24/js/encoding/</url>
    <content><![CDATA[<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><p>为了搞清楚 Javascript 中字符串与编码相关的问题和解决方案，我们首先需要了解字符编码的基本概念。<a href="/2022/03/06/misc/encoding/">文章</a>介绍了字符集（Character Set）、字符编码（Character Encoding）、码点（Code Point)、编码单元（Code Unit）等概念，以及 UCS2 和 UTF16 两种编码方案的内容与区别。</p>
<p>Javascript 编码问题都要考虑以下这些情况的处理。</p>
<ol>
<li>中文、日文、英文等多语言支持问题</li>
<li>字符的规范化问题，同一个字符可以单个码点表示，也可以使用单个码点加组合形式。</li>
<li>有些字符只有码点组合形式，没有对应的正规化复合形式（Normalization Form Composition）。</li>
<li>有些字符可以使用多个组合符号（Combining Mark）</li>
<li>字符边界问题（Grapheme Cluster Boundaries）</li>
</ol>
<h1 id="源码的编码形式"><a href="#源码的编码形式" class="headerlink" title="源码的编码形式"></a>源码的编码形式</h1><p><a href="https://262.ecma-international.org/6.0/#sec-source-text">ECMAScript 规范</a>规定源码可以使用任何合法的码点（Code Point）序列，以码点序列作为输入进行处理，对于实际存储使用的编码方案无要求，只要能转换得到对应码点序列即可。</p>
<p>源码的 Unicode 码点序列中如果包括组合字符序列（combining character sequence），不会对其进行组合当成一个字符而是对每个码点当成一个字符处理。</p>
<p>Java 和 Javascript 对于源码中出现的 Unicode 转义序列处理方式不同，Java 会把转义序列替换为对应字符，然后做解析处理。因此换行符（LINE FEED）转义序列\u000A 会中断注释行和字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的代码相当于两行单行注释</span></span><br><span class="line"><span class="comment">// comment line \u000A // new line</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串被换行符断开，这种写法语法错误，需要使用\n的形式在字符串中表示换行符</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;before \u000A new line&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Javascript 不对 Unicode 转义序列进行预处理，转义序列是语法结构的一部分。字符串、正则表达式、模板字符串、标识符等语法结构中，可以使用 Unicode 转义序列（Unicode escape sequence）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一行单行注释</span><br><span class="line">// comment line \u000A // new line</span><br><span class="line">// 合法字符串</span><br><span class="line">const str = &#x27;before \u000A new line&#x27;</span><br><span class="line"></span><br><span class="line">// 变量名称是 sta</span><br><span class="line">const st\u0061 = &#x27;identifier name sta&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="内部格式"><a href="#内部格式" class="headerlink" title="内部格式"></a>内部格式</h2><p>规范 <a href="https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-string-type">The String Type</a>规定了 Javascript 中的字符串的内部存储格式是顺序的 16 位编码单元序列，最多可以包含 2^53 - 1 个编码单元。</p>
<blockquote>
<p>The String type is the set of all ordered sequences of zero or more 16-bit unsigned integer values (“elements”) up to a maximum length of 2^53 - 1 elements.</p>
</blockquote>
<p>编码单元序列可以表示整个 Unicode 的编码范围（0x0000 ~ 0x10FFFF），但是对代理对的处理跟 UCS2 和 UCS16 有区别。</p>
<p>UCS2 是 16 位定长编码，只能表示基本平面（0x0000 ~ 0xFFFF）内的字符，不能表示补充平面的字符。UTF16 是变长编码，使用一个编码单元表示基本平面内的字符，使用两个编码单元的代理对（Surrogate Pair）表示补充平面字符，但是不允许非法的代理对。</p>
<p>Javascript 中的编码相比于 UCS2 多了<strong>代理对</strong>的支持，相比于 UTF16 又允许<strong>非法的代理对</strong>，码点编码分为三种情况。</p>
<ol>
<li>不属于代理对的单个编码单元代表具有相同数值的码点，单个编码单元<code>\u0061</code>代表了英文字母<code>&quot;a&quot;</code>。</li>
<li>合法的两个连续的编码单元，第一个是高代理对，第二个是低代理对，这两个合起来被认为是相应的码点。<code>&#39;\uD83D\uDE00&#39;</code>代表了字符<code>&#39;😀&#39;</code>（U+1F600 GRINNING FACE）。</li>
<li>不在合法代理对形式中的单个代理对代表具有相同数值的码点，编码单元<code>&#39;\uD800&#39;</code>就代表码点<code>\u&#123;D800&#125;</code>，只不过这个码点在 Unicode 中没有对应的文字。</li>
</ol>
<h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p><a href="https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-literals-string-literals">String Literal</a>规定了 Javascript 字符串字面量书写的语法形式。Javascript 中的字符串可以使用单引号或者双引号对，区别在于使用单引号时，字符串内部的单引号需要用转义形式<code>\&#39;</code>，双引号同理需要使用<code>\&quot;</code>。</p>
<p>Unicode 中基本平面内的字符或者<code>&#39;😀&#39;</code>等补充平面中的字符都可以直接书写，因为字符串内可以使用符合源码字符（<a href="https://tc39.es/ecma262/multipage/ecmascript-language-source-code.html#prod-SourceCharacter">SourceCharacter</a>）形式的任意字符，也就是除了单双引号、反斜杠、换行符之外的所有 Unicode 字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chinese = <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"><span class="keyword">let</span> grinningFace = <span class="string">&#x27;😀&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另外可以使用多种形式的转义序列（EscapeSequence）来表示任意 Unicode 字符，关于 Javascript 中转义序列的细节可以参考<a href="https://mathiasbynens.be/notes/javascript-escapes">文章</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单字符转义序列</span></span><br><span class="line"><span class="keyword">let</span> singleCharacterEscapeSequence = <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(singleCharacterEscapeSequence) <span class="comment">// =&gt; &quot;&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 16进制转义序列</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalEscapeSequence = <span class="string">&#x27;\x61&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hexadecimalEscapeSequence) <span class="comment">// =&gt; &quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unicode转义序列</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;My face \uD83D\uDE00&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str) <span class="comment">// =&gt; &#x27;My face 😀&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6新增的unicode码点转义序列</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Funny cat \u&#123;1F639&#125;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str) <span class="comment">// =&gt; &#x27;Funny cat 😹&#x27;</span></span><br></pre></td></tr></table></figure>

<p>补充平面中的字符可以使用 Unicode 转义序列代理对的形式书写，也可以使用 Unicode 码点转义序列形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> spNiceEmoticon = <span class="string">&#x27;\uD83D\uDE07&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(spNiceEmoticon) <span class="comment">// =&gt; &#x27;😇&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> niceEmoticon = <span class="string">&#x27;\u&#123;1F607&#125;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(niceEmoticon) <span class="comment">// =&gt; &#x27;😇&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(niceEmoticon === spNiceEmoticon) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>这两种形式表示的字符串是相同的，字面量会使用 <a href="https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-static-semantics-sv">MV&#x2F;SV</a> 的语意转换为<strong>相同的</strong>内部 16 位编码单元序列<code>&#39;\uD83D\uDE07&#39;</code>。</p>
<blockquote>
<p>When generating these String values Unicode code points are UTF-16 encoded as defined in 11.1.1.</p>
</blockquote>
<h2 id="相等性"><a href="#相等性" class="headerlink" title="相等性"></a>相等性</h2><p>由于 Javascript 内部使用 16 位编码单元序列表示字符串，所以两个字符串相等的含义是代表字符串的两个编码<a href="https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluenonnumeric">单元序列完全一致</a>，长度相同而且在相同下标的编码单元数值相同。</p>
<p>对于普通字符串来说这个含义符合我们的预期<code>&#39;a&#39; === &#39;\u0061&#39;</code>。</p>
<p>但是对于组合字符来说，同一个字符可以表为不同的码点序列。下面的例子中<code>str1</code>使用了规范化的组合形式（Normalization Form Composition）表示<a href="https://codepoints.net/U+00E7">单个字符</a><code>&#39;ç&#39;</code>，被保存为<code>&#39;\u00E7&#39;</code>；<code>str2</code>使用了组合的形式<code>&#39;c\u0327&#39;</code>，被保存为<code>\u0063\u0327</code>。字符相同，但是使用的编码单元序列不同，因此这两个字符不相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1) <span class="comment">// =&gt; &#x27;ça va bien&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;c\u0327a va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2) <span class="comment">// =&gt; &#x27;ça va bien&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1 === str2) <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>字符串的长度（<a href="https://tc39.es/ecma262/multipage/text-processing.html#sec-properties-of-string-instances-length">length</a>）是 16 位编码单元的个数，但是有些额外情况导致长度返回值和直观预期可能并不一致，参考文章<a href="https://mathiasbynens.be/notes/javascript-unicode#counting-symbols">1</a>, <a href="https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#33-string-length">2</a>。</p>
<h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>对于基本平面中的字符，编码单元的个数就是字符的个数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="property">length</span> <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// U+554A</span></span><br><span class="line"><span class="string">&#x27;啊&#x27;</span>.<span class="property">length</span> <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>

<h3 id="补充平面字符"><a href="#补充平面字符" class="headerlink" title="补充平面字符"></a>补充平面字符</h3><p>对于补充平面中的字符来说，一个字符需要两个编码单元表示，为了获得预期的字符个数，需要将表示一个代理对的两个编码单元当成一个字符处理。可以使用<a href="https://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols">string’s iterator</a>来获得字符串的码点序列，然后返回码点序列的码点个数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countSymbols</span>(<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(string).<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countSymbols</span>(<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...string].<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了获得码点序列长度遍历了字符串的所有码点会造成浪费，只需要字符串长度的话，可以使用 <a href="https://github.com/mathiasbynens/punycode.js">punycode</a> 库。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countSymbols</span>(<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> punycode.<span class="property">ucs2</span>.<span class="title function_">decode</span>(string).<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countSymbols</span>(<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> punycode.<span class="property">ucs2</span>.<span class="title function_">decode</span>(string).<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以选择自行实现代理对处理的逻辑来获得正确的码点个数。</p>
<h3 id="组合字符"><a href="#组合字符" class="headerlink" title="组合字符"></a>组合字符</h3><p>对于组合字符不同编码形式使用的编码单元个数不同，因此字符串长度也不相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1) <span class="comment">// =&gt; &#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="property">length</span>) <span class="comment">// =&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;c\u0327a va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2) <span class="comment">// =&gt; &#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2.<span class="property">length</span>) <span class="comment">// =&gt; 11</span></span><br></pre></td></tr></table></figure>

<p>如果想码点（Code Point）的个数，可以将字符串进行规范化（Normalization Form Composition），使用统一的编码形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1) <span class="comment">// =&gt; &#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">normalize</span>().<span class="property">length</span>) <span class="comment">// =&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;c\u0327a va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2) <span class="comment">// =&gt; &#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2.<span class="title function_">normalize</span>().<span class="property">length</span>) <span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure>

<p>但不是所有的组合字符序列代表的单个字符都有对应的经典形式（Canonical Form），例如字符<code>&#39;ȩ́&#39;</code>包含了一个基础字符<code>&#39;e&#39;</code>和两个组合字符（Combining Mark）<code>\u0327\u0301</code>，正规化的结果只能表示为<code>&#39;ȩ\u0301&#39;</code>，所以正规化后的字符串长度是 5。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含4个字符</span></span><br><span class="line"><span class="keyword">const</span> drink = <span class="string">&#x27;cafe\u0327\u0301&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink) <span class="comment">// =&gt; &#x27;cafȩ́&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="property">length</span>) <span class="comment">// =&gt; 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="title function_">normalize</span>()) <span class="comment">// =&gt; &#x27;cafȩ́&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink.<span class="title function_">normalize</span>().<span class="property">length</span>) <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>

<p>考虑补充平面字符和组合字符同时存在的情况，可以先进行规范化，然后获取码点个数作为字符串长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countSymbolsPedantically</span>(<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="comment">// Unicode Normalization, NFC form, to account for lookalikes:</span></span><br><span class="line">  <span class="keyword">var</span> normalized = string.<span class="title function_">normalize</span>(<span class="string">&#x27;NFC&#x27;</span>)</span><br><span class="line">  <span class="comment">// Account for astral symbols / surrogates, just like we did before:</span></span><br><span class="line">  <span class="keyword">return</span> punycode.<span class="property">ucs2</span>.<span class="title function_">decode</span>(normalized).<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更夸张的情况是泰文中可以使用任意个数的组合字符，出现比较奇葩的效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看着是6个字符，但是每个字符都包含很多个组合字符。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="title function_">countSymbolsPedantically</span>(<span class="string">&#x27;Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞&#x27;</span>)</span><br><span class="line"><span class="number">74</span> <span class="comment">// not 6</span></span><br></pre></td></tr></table></figure>

<p>这种情况可以通过利用正则表达式将组合字符去掉，只保留基础字符来获取正确的字符个数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Note: replace the following regular expression with its transpiled equivalent</span></span><br><span class="line"><span class="comment">// to make it work in old environments. https://mths.be/bwm</span></span><br><span class="line"><span class="keyword">var</span> regexSymbolWithCombiningMarks = <span class="regexp">/(\P&#123;Mark&#125;)(\p&#123;Mark&#125;+)/gu</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countSymbolsIgnoringCombiningMarks</span>(<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="comment">// Remove any combining marks, leaving only the symbols they belong to:</span></span><br><span class="line">  <span class="keyword">var</span> stripped = string.<span class="title function_">replace</span>(</span><br><span class="line">    regexSymbolWithCombiningMarks,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">$<span class="number">0</span>, symbol, combiningMarks</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> symbol</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// Account for astral symbols / surrogates, just like we did before:</span></span><br><span class="line">  <span class="keyword">return</span> punycode.<span class="property">ucs2</span>.<span class="title function_">decode</span>(stripped).<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h3><p>Unicode 中除了上面的组合字符的情况，还有多个独立字符可以共同合成一个字符的情况。</p>
<p>韩文 நி (ந + ி)和 깍 (ᄁ + ᅡ + ᆨ)。</p>
<p>颜文字 👨‍👩‍👧‍👦 (👨 + U+200D ZERO WIDTH JOINER + 👩 + U+200D ZERO WIDTH JOINER + 👧 + U+200D ZERO WIDTH JOINER + 👦)。</p>
<p>可以参考 UAX 中关于<a href="http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">字符边界的算法</a>，规定了码点序列中到底哪些字符合起来构成一个字形（Grapheme），这个概念才真正对应常规意义上的单个字符。</p>
<h2 id="String-prototype-对象方法"><a href="#String-prototype-对象方法" class="headerlink" title="String.prototype 对象方法"></a>String.prototype 对象方法</h2><h3 id="charAt-amp-charCodeAt-amp-fromCharCode"><a href="#charAt-amp-charCodeAt-amp-fromCharCode" class="headerlink" title="charAt &amp; charCodeAt &amp; fromCharCode"></a>charAt &amp; charCodeAt &amp; fromCharCode</h3><p><code>chartCodeAt</code>方法获取字符串指定下标的编码单元，返回结果是数字；<code>charAt</code>方法获取字符串在指定下标的编码单元对应的字符，返回结果是字符串。这两个方法查询的下标对应基本平面内字符时结果正确，对应代理对时结果将代理对拆分，单个处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;💩&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) <span class="comment">// \uD83D</span></span><br><span class="line"><span class="string">&#x27;💩&#x27;</span>.<span class="title function_">charAt</span>(<span class="number">0</span>) <span class="comment">// \uD83D 没有对应字符渲染为 &#x27;�&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;💩&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">1</span>) <span class="comment">// \uDCA9</span></span><br><span class="line"><span class="string">&#x27;💩&#x27;</span>.<span class="title function_">charAt</span>(<span class="number">1</span>) <span class="comment">// \uDCA9 \uD83D 没有对应字符渲染为 &#x27;�&#x27;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://tc39.es/ecma262/multipage/text-processing.html#sec-string.fromcharcode"><code>fromCharCode</code></a>从给定编码单元数值创建对应字符，超过 0xFFFF 的数值会被截断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x0041</span>) <span class="comment">// U+0041</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span> <span class="comment">// U+0041</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x1F4A9</span>) <span class="comment">// U+1F4A9</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> <span class="comment">// U+F4A9, not U+1F4A9</span></span><br></pre></td></tr></table></figure>

<h3 id="at-amp-codePointAt-amp-fromCodePoint"><a href="#at-amp-codePointAt-amp-fromCodePoint" class="headerlink" title="at &amp; codePointAt &amp; fromCodePoint"></a>at &amp; codePointAt &amp; fromCodePoint</h3><p><a href="https://tc39.es/ecma262/multipage/ecmascript-language-source-code.html#sec-codepointat"><code>codePointAt</code></a>获取字符串指定下标位置的码点，如果下标位置开始是个合法代理对，返回代理对代表的码点，否则返回下标所在单个编码单元值对应的码点，返回结果是数字类型；<code>at</code>处理相同，返回结果是字符串类型（ES7 规范内容）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;💩&#x27;</span>.<span class="title function_">at</span>(<span class="number">0</span>) <span class="comment">// U+1F4A9</span></span><br><span class="line"><span class="string">&#x27;💩&#x27;</span>.<span class="title function_">codePointAt</span>(<span class="number">0</span>) <span class="comment">// U+1F4A9</span></span><br></pre></td></tr></table></figure>

<p><a href="https://tc39.es/ecma262/multipage/text-processing.html#sec-string.fromcodepoint"><code>String.fromCodePoint</code></a>从给点的码点序列创建字符串，如果码点序列不是整数或者超出了 Unicode 码点范围 0x10FFFF 会抛出<code>RangeError</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(<span class="number">0x1f4a9</span>) <span class="comment">// &#x27;💩&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h3><p>使用<code>normalize</code><a href="https://tc39.es/ecma262/multipage/text-processing.html#sec-string.prototype.normalize">方法</a>对字符串进行正规化，有四个选项。</p>
<p>‘NFC’ as Normalization Form Canonical Composition<br>‘NFD’ as Normalization Form Canonical Decomposition<br>‘NFKC’ as Normalization Form Compatibility Composition<br>‘NFKD’ as Normalization Form Compatibility Decomposition</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;ça va bien&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;c\u0327a va bien&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">normalize</span>() === str2.<span class="title function_">normalize</span>()) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1 === str2)</span><br></pre></td></tr></table></figure>

<p>规范化的过程参考<a href="https://unicode.org/reports/tr15/">Unicode® Standard Annex #15 UNICODE NORMALIZATION FORMS</a></p>
<h3 id="遍历字符串码点"><a href="#遍历字符串码点" class="headerlink" title="遍历字符串码点"></a>遍历字符串码点</h3><p>字符串存储为 16 位编码单元，所以遍历字符串编码单元非常简单。遍历字符串内的<strong>码点序列</strong>需要处理代理对，可以手动实现这个逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSymbols</span>(<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> length = string.<span class="property">length</span></span><br><span class="line">  <span class="keyword">var</span> output = []</span><br><span class="line">  <span class="keyword">for</span> (; index &lt; length; ++index) &#123;</span><br><span class="line">    <span class="keyword">var</span> charCode = string.<span class="title function_">charCodeAt</span>(index)</span><br><span class="line">    <span class="keyword">if</span> (charCode &gt;= <span class="number">0xd800</span> &amp;&amp; charCode &lt;= <span class="number">0xdbff</span>) &#123;</span><br><span class="line">      charCode = string.<span class="title function_">charCodeAt</span>(index + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (charCode &gt;= <span class="number">0xdc00</span> &amp;&amp; charCode &lt;= <span class="number">0xdfff</span>) &#123;</span><br><span class="line">        output.<span class="title function_">push</span>(string.<span class="title function_">slice</span>(index, index + <span class="number">2</span>))</span><br><span class="line">        ++index</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output.<span class="title function_">push</span>(string.<span class="title function_">charAt</span>(index))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> symbols = <span class="title function_">getSymbols</span>(<span class="string">&#x27;💩&#x27;</span>)</span><br><span class="line">symbols.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">symbol</span>) &#123;</span><br><span class="line">  <span class="title function_">assert</span>(symbol == <span class="string">&#x27;💩&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以利用 String 类型的<a href="https://tc39.es/ecma262/multipage/text-processing.html#sec-string.prototype-@@iterator">迭代器协议</a>，<a href="https://tc39.es/ecma262/multipage/text-processing.html#sec-string-iterator-objects">字符串迭代器对象</a>返回字符串的码点序列，每个码点以<strong>字符串</strong>形式返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&#x27;\ud83d\udc0e\ud83d\udc71\u2764&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for-of循环利用了迭代器协议</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> string) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(codePoint.<span class="title function_">codePointAt</span>(<span class="number">0</span>).<span class="title function_">toString</span>(<span class="number">16</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;1f40e&#x27;, &#x27;1f471&#x27;, &#x27;2764&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(string)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部使用了迭代器协议</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="function">(<span class="params">codePoint</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(codePoint)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>.<span class="title function_">call</span>(<span class="function">(<span class="params">codePoint</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(codePoint)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="大小写处理"><a href="#大小写处理" class="headerlink" title="大小写处理"></a>大小写处理</h3><p>locale 相关操作 localeCompare&#x2F;toLocaleLowerCase&#x2F;toLocaleUpperCase</p>
<p>大小写转换处理 toLowerCase &#x2F; toUpperCase</p>
<h3 id="String-prototype-的其他-API"><a href="#String-prototype-的其他-API" class="headerlink" title="String.prototype 的其他 API"></a>String.prototype 的其他 API</h3><p>全局字符串对象原型<code>String.prototype</code>上的<a href="https://tc39.es/ecma262/multipage/text-processing.html#sec-properties-of-the-string-prototype-object">其他操作</a>也都是对 16 位编码单元序列进行处理的，也会因为补充平面字符、组合字符、字符边界等情况出现与预期不一致的结果，在使用时需要注意。</p>
<h2 id="形式转换"><a href="#形式转换" class="headerlink" title="形式转换"></a>形式转换</h2><p>字符串的处理需要在 16 位编码单元序列和码点序列两个形式之间进行转换，<a href="https://tc39.es/ecma262/multipage/ecmascript-language-source-code.html#sec-source-text">规范</a>中使用了以下抽象操作描述正反向的转换过程。</p>
<p>码点序列转换为 16 位编码单元序列，<code>CodePointsToString(codePoints)</code>将的码点序列<code>codePoints</code>转换为 16 位编码单元序列，内部调用<code>UTF16EncodeCodePoint(cp)</code>将单个码点<code>cp</code>转换为 16 位编码单元代表的字符串。</p>
<p>16 位编码单元序列转换为码点序列，<code>StringToCodePoints(string)</code>将<code>string</code>转换为对应的码点序列，内部调用<code>CodePointAt(string, position)</code>获取位置<code>position</code>对应的码点，再嵌套调用 <code>UTF16SurrogatePairToCodePoint(lead, trail)</code>将内部的 16 位编码单元序列中代理对转换为对应码点，返回数字类型。</p>
<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>基本平面中的非组合字符反转字符串非常简单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充平面中的字符需要先获得码点序列再进行反转操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...str].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于组合字符的情况，位置反转会造成组合字符对应的基础字符不同，所以反转结果与预期不一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反转前修饰字符n，反转后修饰字符a</span></span><br><span class="line">;[...<span class="string">&#x27;mañana&#x27;</span>].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;anãnam&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://mathiasbynens.be/notes/javascript-unicode#counting-symbols#reversing-strings">综合考虑以上情况</a>，可以使用<a href="https://github.com/mathiasbynens/esrever">esrever</a>库来处理代理对、组合字符串等问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">esrever.<span class="title function_">reverse</span>(<span class="string">&#x27;mañana&#x27;</span>) <span class="comment">// &#x27;anañam&#x27;</span></span><br><span class="line"></span><br><span class="line">esrever.<span class="title function_">reverse</span>(<span class="string">&#x27;💩&#x27;</span>) <span class="comment">// &#x27;💩&#x27; U+1F4A9</span></span><br></pre></td></tr></table></figure>

<h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw"></a>String.raw</h2><p><a href="https://mothereff.in/js-escapes#1%F0%9D%8C%86">String.raw</a>是模板字符串标签函数，用来保留模板字符串中的转义序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \n 表示换行符</span></span><br><span class="line">;<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span> + <span class="number">3</span>&#125;</span>!`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// \n 表示反斜杠\和字符n，而不是换行符</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span> + <span class="number">3</span>&#125;</span>!`</span></span><br></pre></td></tr></table></figure>

<h2 id="子串匹配操作"><a href="#子串匹配操作" class="headerlink" title="子串匹配操作"></a>子串匹配操作</h2><p>抽象操作<a href="https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-stringindexof">StringIndexOf</a>定义了子串匹配的过程。</p>
<h2 id="静态语义-MV-x2F-SV"><a href="#静态语义-MV-x2F-SV" class="headerlink" title="静态语义 MV &#x2F; SV"></a>静态语义 MV &#x2F; SV</h2><p>字符串的 <a href="https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-string-literals-static-semantics-mv">MV</a> 语义从字符串字面量获得对应 16 位编码序列代表的整数值。</p>
<p>字符串的 <a href="https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-static-semantics-sv">SV</a> 语义从字符串字面量获得对应的 16 位编码序列。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式也默认使用 16 位编码单元处理字符匹配，因此在处理补充平面字符时可能出现与预期不一致的情况。</p>
<h2 id="字符个数匹配"><a href="#字符个数匹配" class="headerlink" title="字符个数匹配"></a>字符个数匹配</h2><p>点号（.）在正则表达式中匹配单个字符，但是对于表示成代理对的补充平面字符无法匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> smile = <span class="string">&#x27;😀&#x27;</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^.$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(smile)) <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<p>为了匹配 16 位编码单元序列代表的所有合法 Unicode 字符串序列，可以编写特定模式进行匹配，将 Unicode 码点分为四类。</p>
<ol>
<li>基本平面中不属于代理对的字符 <code>/[\0-\uD7FF\uE000-\uFFFF]</code></li>
<li>两个 16 位编码单元的代理对 <code>/[\uD800-\uDBFF][\uDC00-\uDFFF]/</code></li>
<li>不属于代理对的单个高代理（lead surrogate）编码单元 <code>/[\uD800-\uDBFF](?![\uDC00-\uDFFF])/</code></li>
<li>不属于代理对的单个低代理（trail surrogate）编码单元 <code>/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/</code></li>
</ol>
<p>将这四种情况组合起来就能匹配所有 Unicode 字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/</span>.<span class="title function_">test</span>(</span><br><span class="line">  <span class="string">&#x27;💩&#x27;</span></span><br><span class="line">) <span class="comment">// wtf</span></span><br></pre></td></tr></table></figure>

<p>使用<a href="https://mths.be/regenerate">regenerate</a>库可以方便的生成匹配指定 Unicode 码点范围的正则表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">regenerate</span>().<span class="title function_">addRange</span>(<span class="number">0x0</span>, <span class="number">0x10ffff</span>).<span class="title function_">toString</span>()</span><br></pre></td></tr></table></figure>

<p>使用 ES6 新增的正则表达式标志 u 开启 Unicode 支持，也可以解决点号匹配的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> smile = <span class="string">&#x27;😀&#x27;</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^.$/u</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(smile)) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<h2 id="字符范围匹配"><a href="#字符范围匹配" class="headerlink" title="字符范围匹配"></a>字符范围匹配</h2><p>在正则表达式范围匹配形式中直接使用补充平面字符会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/[💩-💫]/</span></span><br><span class="line"><span class="comment">// =&gt; SyntaxError: Invalid regular expression: /[💩-💫]/:</span></span><br><span class="line"><span class="comment">// Range out of order in character class</span></span><br></pre></td></tr></table></figure>

<p>因为上面的形式相当于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="regexp">/[\uD83D\uDCA9-\uD83D\uDCAB]/</span></span><br></pre></td></tr></table></figure>

<p>中间的范围是一个开始值比结束值大的非法范围。同样可以使用 u 标志开启对 Unicode 字符的支持。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="regexp">/[\uD83D\uDCA9-\uD83D\uDCAB]/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDCA9&#x27;</span>) <span class="comment">// match U+1F4A9</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="regexp">/[\u&#123;1F4A9&#125;-\u&#123;1F4AB&#125;]/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;\u&#123;1F4AA&#125;&#x27;</span>) <span class="comment">// match U+1F4AA</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="regexp">/[💩-💫]/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;💪&#x27;</span>) <span class="comment">// match U+1F4AA</span></span><br></pre></td></tr></table></figure>

<p>如果需要在 ES5 等环境中进行兼容处理，同样可以使用 regenerate 库生成相应 Unicode 字符匹配形式。</p>
<h2 id="组合字符-1"><a href="#组合字符-1" class="headerlink" title="组合字符"></a>组合字符</h2><p>正则表达式的 Unicode 支持标志 u 无法处理组合字符（Combining Mark），因为即使开启了 Unicode 支持，也是以单个码点作为字符进行匹配，组合字符的形式是由多个码点组成的，这种情况下只能通过将基础字符（base character）和组合字符（Combining Mark）分开书写为模式进行匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> drink = <span class="string">&#x27;cafe\u0301&#x27;</span></span><br><span class="line"><span class="keyword">const</span> regex1 = <span class="regexp">/^.&#123;4&#125;$/</span></span><br><span class="line"><span class="keyword">const</span> regex2 = <span class="regexp">/^.&#123;5&#125;$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(drink) <span class="comment">// =&gt; &#x27;café&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex1.<span class="title function_">test</span>(drink)) <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex2.<span class="title function_">test</span>(drink)) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>上面例子中<code>drink</code>代表的字符包含五个码点。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>对 Javascript 中字符串与编码问题可以阅读以下内容。</p>
<ol>
<li><a href="https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/">What every JavaScript developer should know about Unicode</a></li>
<li><a href="https://cjting.me/2018/07/22/js-and-unicode/">JavaScript 与 Unicode</a></li>
<li>《Effective Javascript》 Item 7 Think of Strings As Sequences of 16-bit Code Units</li>
<li>《Understanding ECMAScript 6》Chapter 2 String and Regular Expressions<br>ECMAScript 规范中与字符串相关的内容。</li>
</ol>
<p>更深入细致的介绍可以参考 Mathias Bynens 的系列博客。</p>
<p>字符串编码系列</p>
<ol>
<li><a href="https://mathiasbynens.be/notes/javascript-unicode">JavaScript has a Unicode problem</a></li>
<li><a href="https://mathiasbynens.be/notes/javascript-escapes">JavaScript character escape sequences</a></li>
<li><a href="https://mathiasbynens.be/notes/javascript-encoding">JavaScript’s internal character encoding: UCS-2 or UTF-16? </a></li>
</ol>
<p>正则表达式系列</p>
<ol>
<li><a href="https://mathiasbynens.be/notes/es-regexp-proposals">ECMAScript regular expressions are getting better!</a></li>
<li><a href="https://mathiasbynens.be/notes/es-unicode-property-escapes">Unicode property escapes in JavaScript regular expressions</a></li>
<li><a href="https://mathiasbynens.be/notes/es6-unicode-regex">Unicode-aware regular expressions in ES2015</a></li>
</ol>
<p>最后对于具体的细节可以参考 ECMAScript 规范中涉及到字符串与编码的相关内容。</p>
<ol>
<li><a href="https://262.ecma-international.org/6.0/#sec-source-text">Source Text</a> <a href="https://tc39.es/ecma262/multipage/ecmascript-language-source-code.html#sec-ecmascript-language-source-code">ES2022</a></li>
<li><a href="https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-ecmascript-language-lexical-grammar-literals">ECMAScript Language: Lexical Grammar String Literals</a></li>
<li><a href="https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-string-type">ECMAScript Data Types and Values The String Type</a></li>
<li><a href="https://tc39.es/ecma262/multipage/text-processing.html#sec-string-objects">Text Process String Objects</a></li>
</ol>
]]></content>
      <categories>
        <category>深入理解Javascript</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>Unicode</tag>
        <tag>字符串</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript中什么是合法变量名？</title>
    <url>/2022/02/24/js/identifier-name/</url>
    <content><![CDATA[<h1 id="Javascript-vs-C"><a href="#Javascript-vs-C" class="headerlink" title="Javascript vs C"></a>Javascript vs C</h1><p>下面这段代码在 Javascript 中是合法的变量赋值语句，但是在 C 语言中并不合法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>原因在于 Javascript 和 C 语言对于合法的变量名称规定不同。本文以 ECMAScript 规范为依据，对这个问题进行探讨。文中使用了标识符名称（IdentifierName）、标识符（Identifier）、保留字（ReservedWord）、关键字（Keyword）等规范中的概念，提示大家在阅读的过程中注意这些概念之间的联系和区别，否则容易混淆。</p>
<h1 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h1><h2 id="合法形式"><a href="#合法形式" class="headerlink" title="合法形式"></a>合法形式</h2><p>Javascript 引擎对代码进行处理时，首先在编译阶段进行分词操作，将源码划分为不同的种类的单词（Token），然后使用单词流作为后续解析的输入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中有几类分词：</p>
<ol>
<li>数字 <code>1</code></li>
<li><strong>标识符（Identifier）</strong> <code>test1</code>&#x2F;<code>a</code></li>
<li><strong>保留字（ReservedWord）</strong><code>function</code>&#x2F;<code>let</code></li>
<li>空白与标点符号</li>
</ol>
<p>函数名、变量名等位置使用的是标识符类型的 Token，由数字、字母组成。另外为了不与数字冲突所以规定标识符不能以数字开头。<code>function</code>&#x2F;<code>let</code>等固定语法位置使用的单词形式上也符合标识符定义，但是因为用作特殊用途，所以这一类单词被划分为保留字类型。</p>
<p>ECMAScript 规范中<a href="https://262.ecma-international.org/6.0/#sec-names-and-keywords">名称与关键字</a>对名称的合法形式进行规定，主要涉及三个概念标识符名称（IdentifierName）、标识符（Identifier）和保留字（ReservedWord）。</p>
<ol>
<li>标识符是指能够作为合法的变量名、函数名、类名、属性名等名称的形式</li>
<li>保留字</li>
<li>标识符和保留字的合法形式统称为标识符名称</li>
</ol>
<p>标识符名称的合法形式使用 BNF 语法规定如下。</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IdentifierName ::</span><br><span class="line">  IdentifierStart</span><br><span class="line">  IdentifierName IdentifierPart</span><br><span class="line"></span><br><span class="line">IdentifierStart ::</span><br><span class="line">  IdentifierStartChar</span><br><span class="line">  \ UnicodeEscapeSequence</span><br><span class="line"></span><br><span class="line">IdentifierPart ::</span><br><span class="line">  IdentifierPartChar</span><br><span class="line">  \ UnicodeEscapeSequence</span><br><span class="line"></span><br><span class="line">IdentifierStartChar ::</span><br><span class="line">  UnicodeIDStart</span><br><span class="line">  $</span><br><span class="line">  _</span><br><span class="line"></span><br><span class="line">IdentifierPartChar ::</span><br><span class="line">  UnicodeIDContinue</span><br><span class="line">  $</span><br><span class="line">  <span class="attribute">&lt;ZWNJ&gt;</span></span><br><span class="line">  <span class="attribute">&lt;ZWJ&gt;</span></span><br></pre></td></tr></table></figure>

<p>关键的含义有两点。</p>
<ol>
<li>标识符名称的首字母必须满足 IdentifierStartChar 的规定，也就是可以使用<code>$</code>、<code>_</code>和 Unicode 中能作为名称首字母的字符（UnicodeIDStart）。</li>
<li>标识符名称的后续字母必须满足 IdentifierPartChar 的规定，可以是<code>$</code>、<code>&lt;ZWNJ&gt;</code>、<code>&lt;ZWJ&gt;</code>和 Unicode 中能作为名称后续字母的字符（UnicodeIDContinue）。其中<code>UnicodeIDContinue</code>包含了<code>UnicodeIDStart</code>、<code>_</code>、数字和其他一些合法字符。</li>
</ol>
<p>也就是说后续字符包含的范围比首字符要大。Javascript 相比于 C 语言允许更多字符作为标识符</p>
<ol>
<li>开头允许 U+0024 (DOLLAR SIGN) and U+005F (LOW LINE)</li>
<li>后续字符允许 U+200C (ZERO WIDTH NON-JOINER) and U+200D (ZERO WIDTH JOINER)</li>
</ol>
<p>这解释了<code>$a = 1</code>在 Javascript 中合法但是在 C 语言中非法的现象。</p>
<h2 id="中文名称"><a href="#中文名称" class="headerlink" title="中文名称"></a>中文名称</h2><p>标识符合法形式中允许使用 Unicode 码点分类 UnicodeIDStart&#x2F;UnicodeIDContinue，这意味着我们可以使用中文、日文、韩文等字符作为名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 姓 = <span class="string">&#x27;李&#x27;</span></span><br><span class="line"><span class="keyword">const</span> 名 = <span class="string">&#x27;白&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> 问好(姓, 名) &#123;</span><br><span class="line">  <span class="keyword">const</span> greeting = <span class="string">`你好，<span class="subst">$&#123;姓&#125;</span><span class="subst">$&#123;名&#125;</span> 🤪`</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你好，李白 🤪</span></span><br><span class="line">问好(姓, 名)</span><br></pre></td></tr></table></figure>

<p>上面代码中函数名、参数名、变量名都使用了中文，是合法的形式。</p>
<h2 id="UnicodeIDStart-和-UnicodeIDContinue"><a href="#UnicodeIDStart-和-UnicodeIDContinue" class="headerlink" title="UnicodeIDStart 和 UnicodeIDContinue"></a>UnicodeIDStart 和 UnicodeIDContinue</h2><p>完整的 UnicodeIDStart 和 UnicodeIDContinue 包含的字符可以参考<a href="https://www.unicode.org/reports/tr31/">Unicode® Standard Annex #31</a>中 Default Identifier Syntax 的内容。</p>
<p>Babel 对于标识符的相关实现位于<a href="https://github.com/babel/babel/blob/main/packages/babel-helper-validator-identifier/src/identifier.ts">这里</a>，使用<a href="https://www.npmjs.com/package/@unicode/unicode-14.0.0">Unicode v14.0.0</a>提取合法的码点范围并生成正则表达式来检测合法名称字符。</p>
<p>粗略来说，合法的名称字符包括了几类。</p>
<table>
  <tr>
    <th>码点范围</th>
    <th>分类</th>
    <th>字符</th>
  </tr>
  <tr>
    <td>0x00 - 0xff</td>
    <td>ASCII 字符集</td>
    <td>英文大写字母、小写字母、数字和几个特殊字符$、_</td>
  </tr>
  <tr>
    <td>0x0100 - 0xffff</td>
    <td>Unicode 基础平面 BMP 中的合法字符</td>
    <td>中文、日文、韩文</td>
  </tr>
  <tr>
    <td>0x01000 - 0x10ffff</td>
    <td><a href="https://mathiasbynens.be/notes/javascript-identifiers-es6#acceptable-unicode-symbols"> Unicode 补充平面（Astral）<a>，ES 5不允许使用非补充平面字符作为标识符，ES6开始允许</td>
    <td>其他字符</td>
  </tr>
</table>

<h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h2><p>标识符名称支持使用 Unicode 转义序列<a href="https://262.ecma-international.org/6.0/#sec-literals-string-literals">UnicodeEscapeSequence</a>来表示 Unicode 字符，方便在不能直接使用 Unicode 字符的情况下使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// \u0041 是字符&#x27;A&#x27;的转义序列</span><br><span class="line">let \u0041 = 1;</span><br><span class="line">console.log(&#x27;A: &#x27;, A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// \u&#123;0042&#125; 是字符&#x27;B&#x27;的转义序列</span><br><span class="line">let \u&#123;0042&#125; = 2;</span><br><span class="line">console.log(&#x27;B: &#x27;, B)</span><br></pre></td></tr></table></figure>

<p>上面使用了 Unicode 转义序列的两种形式分别定义了变量 A 和 B，<code>\u HexDigits</code>的形式只能表示 Unicode 中基本平面的字符，<code>\u&#123;CodePoint&#125;</code>的形式能表示 Unicode 中的所有字符，完整的定义如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnicodeEscapeSequence ::</span><br><span class="line">  u Hex4Digits</span><br><span class="line">  u&#123; CodePoint &#125;</span><br><span class="line"></span><br><span class="line">Hex4Digits ::</span><br><span class="line">  HexDigit HexDigit HexDigit HexDigit</span><br><span class="line"></span><br><span class="line">HexDigit :: one of</span><br><span class="line">  0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</span><br><span class="line"></span><br><span class="line">CodePoint ::</span><br><span class="line">  HexDigits[~Sep] but only if MV of HexDigits ≤ 0x10FFFF</span><br></pre></td></tr></table></figure>

<p>对于错误形式的转义序列，执行时在代码解析阶段就直接报错。</p>
<p><code>\u HexDigits</code>形式必须是<code>\u</code>后面跟着<strong>四个</strong>十六进制字符（HexDigit）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError: Invalid Unicode escape sequence</span></span><br><span class="line"><span class="keyword">const</span> \uaa = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(\uaa)</span><br></pre></td></tr></table></figure>

<p><code>\u&#123;CodePoint&#125;</code>形式中括号对内也是十六进制字符，但是要求代表的码点值必须小于等于（0x10FFFF），也就是位于 Unicode 字符集规定的码点范围内。</p>
<p>下面是几种非法的转义序列形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误，包含了不属于十六进制字符的字符g</span></span><br><span class="line">\u&#123;1g&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，码点范围超出Unicode字符集</span></span><br><span class="line">\u&#123;<span class="number">110000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，\u&#123;42&#125;是字符B的转义形式</span></span><br><span class="line"><span class="keyword">const</span> \u&#123;<span class="number">42</span>&#125; = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B&#x27;</span>, \u&#123;<span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>转义序列除了必须形式正确外，其代表的对应码点也必须是合法的名称字符。<br>例如反撇号&#96;本身不是合法的名称字符，那么使用转义序列的方式书写也是不正确的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \u&#123;40&#125;是反撇号`的转义序列形式</span></span><br><span class="line"><span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="keyword">const</span> \u&#123;<span class="number">40</span>&#125; = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="码点序列语意"><a href="#码点序列语意" class="headerlink" title="码点序列语意"></a>码点序列语意</h2><p>由于允许使用 Unicode 转义序列，所以同一个名称的变量有多种写法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接书写</span></span><br><span class="line">let A = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转义序列形式</span></span><br><span class="line"><span class="comment">// \u0041是 &#x27;A&#x27;的转义形式</span></span><br><span class="line">let \u0041 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>Javascript 中对于标识符名称的处理都是基于码点序列，具有相同码点序列的不同写法被认为是同一个名称。在 ES6 规范中被称为 <a href="https://262.ecma-international.org/6.0/#sec-identifier-names-static-semantics-stringvalue">StringValue</a> 语意，在 ES 2022 中被称为 <a href="https://tc39.es/ecma262/#sec-identifiercodepoints">IdentifierCodePoints</a> 语意，使用的术语不相同，但表达式是同一个意思。因此上面这段代码执行的话会报错，因为同一个名称’A’的变量不允许<strong>重复定义</strong>。</p>
<p>Unicode 中代表相同字符（canonically equivalent）的标识符名称并不一定等价，除非其使用的码点序列相同，参考 <a href="https://262.ecma-international.org/6.0/#sec-names-and-keywords">ES 6 规范</a>。</p>
<blockquote>
<p>Two IdentifierName that are canonically equivalent according to the Unicode standard are not equal unless, after replacement of each UnicodeEscapeSequence, they are represented by the exact same sequence of code points.</p>
</blockquote>
<h2 id="合法标识符名称判断"><a href="#合法标识符名称判断" class="headerlink" title="合法标识符名称判断"></a>合法标识符名称判断</h2><p>通过上面的介绍我们了解了标识符名称的合法形式的定义，主要是两点。</p>
<ol>
<li>首字母必须合法</li>
<li>后续字母必须合法</li>
</ol>
<p>看起来像是废话，但是具体实现逻辑还是有些细节的，这里我们参考<a href="https://github.com/babel/babel/blob/main/packages/babel-helper-validator-identifier/src/identifier.ts#L85">Babel</a>的实现。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isIdentifierName</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> isFirst = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// iterable protocol返回的是code point序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(name)) &#123;</span><br><span class="line">    <span class="keyword">const</span> cp = char.<span class="title function_">codePointAt</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isIdentifierStart</span>(cp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      isFirst = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isIdentifierChar</span>(cp)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// isFirst理解为状态机，包含了空串、单个字符、多个字符情况</span></span><br><span class="line">  <span class="keyword">return</span> !isFirst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现中有几个关键点。</p>
<p>第一点，接受的参数是一个字符串，需要从字符串获取其对应的 Unicode 码点序列。由于 Javascript 的字符串使用的是 UTF16 的变长编码，所以字符串获得指定下标位置字符对应码点的方法<code>codePointAt(index)</code>不能直接使用，需要增加对于代理对（Surrogate Pair）的检查。Babel 的实现没有包含这个逻辑，而是直接使用了<code>Array.from(name)</code>的形式。</p>
<p>原因在于字符串实现了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator">迭代器协议</a>，顺序返回字符串每个字符对应的码点，返回形式也是字符串，所以使用 for 循环遍历时每个字符代表一个码点，再使用<code>codePointAt(0)</code>获得正确码点。</p>
<p>第二点，关于首字母<code>isIdentifierStart</code>和后续字母<code>isIdentifierChar</code>的检测逻辑是前文中讲述的内容。</p>
<p>第三点，整个检测逻辑是一个状态机的实现，<code>isFirst</code>变量可以理解为记录了状态机的匹配状态。状态机的合法结束情况是接受了至少一个字符，而且每个字符都满足对应的要求。状态机结束时函数返回<code>true</code>表示输入是合法的标识符名称。</p>
<p>循环中单个字符非法时直接返回<code>false</code>；如果循环能正确结束表示所有字符合法，这时候还要满足至少一个字符，也就是<code>!isFirst</code>。</p>
<h1 id="名称分类"><a href="#名称分类" class="headerlink" title="名称分类"></a>名称分类</h1><p>下图中对标识符名称、标识符、关键字、保留字等概念的关系进行总结。标识符名称是最大的圈，包含了其他三个概念。保留字和标识符是两个互斥的概念，合起来等于标识符名称。关键字和保留字、标识符各有重合。</p>
<p><img data-src="/images/reserved-word-keyword.jpeg" alt="名称分类"></p>
<p>名称的分类可以参考<a href="https://tc39.es/ecma262/#sec-keywords-and-reserved-words">规范</a>中的表述，其中总是<strong>可以</strong>作为标识符的名称（Math,window,toString 等）和总是<strong>不能</strong>作为标识符的名称（if&#x2F;else 等）两种情况比较清楚，可以重点关注另外的三种情况<span id="conditional-reserved-word"></span>。</p>
<table>
  <tr>
    <th>分类</th>
    <th>列表</th>
  </tr>
  <tr>
    <td>某些条件下可以作为标识符的保留字</td>
    <td>await, yield</td>
  </tr>
  <tr>
    <td>严格模式下激活的保留字 </td>
    <td>let, static, implements, interface, package, private, protected, public</td>
  </tr>
  <tr>
    <td>可以作为标识符的关键字</td>
    <td>as, async, from, get, meta, of, set, target</td>
  </tr>
</table>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字（keyword）是指符合标识符名称（IdentifierName）形式，且出现在<strong>语法结构</strong>中的若干个单词，例如下面代码中的<code>function/if/return</code>等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数关键字不是合法的标识符，也就是不能出现在需要标识符的语法结构位置中，不能用作变量名、函数名、类名等。但是也有个别关键词<a href="#async-await">例外</a>。</p>
<p>ES 6 中的关键字列表如下，Babel 实现的辅助函数<a href="https://github.com/babel/babel/blob/main/packages/babel-helper-validator-identifier/src/keyword.ts#L94">isKeyword</a>与其一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break case catch continue debugger default do else finally for function if return switch throw try var const while with new this super class extends export import null true false in instanceof typeof void delete</span><br></pre></td></tr></table></figure>

<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p><a href="https://262.ecma-international.org/6.0/#sec-reserved-words">保留字</a>（ReservedWord）是指<strong>标识符名称</strong>中不是<strong>标识符</strong>的其余名称。也就是说一个名称如果属于保留字，就不能用到变量名、函数名、类名等需要标识符的语法位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> enum = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中<code>enum</code>是保留字，所以不能作为变量名称使用。但是有些名称作为保留字是<a href="#conditional-reserved-word">有条件的</a>，条件不满足时不是保留字，从而可以作为变量名存在。设计这种机制主要是出于兼容旧代码的考虑，规范新增保留字时，旧代码中可能存在使用新保留字作为变量的情况，为了保证旧代码在新规范下还能正常运行，保留字的触发就需要设置一定条件。</p>
<p>Javascript 的不同版本规范定义的保留字列表有更新变化，可以参考文章<a href="https://mathiasbynens.be/notes/reserved-keywords">Reserved keywords in JavaScript</a>。</p>
<p>当前时间最新规范 ES2022 中的保留字列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await break case catch class const continue debugger default delete do else enum export extends false finally for function if import in instanceof new null return super switch this throw true try typeof var void while with yield</span><br></pre></td></tr></table></figure>

<h2 id="标识符分类"><a href="#标识符分类" class="headerlink" title="标识符分类"></a>标识符分类</h2><p>标识符根据所处的语法位置表示不同的语义，划分为绑定标识符（BindingIdentifier）、标识符引用（IdentifierReference）、标签标识符（LabelIdentifier）和普通标识符（Identifier）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定标识符，定义一个绑定</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用标识符，引用一个绑定</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 标签标识符，标签语句中使用的形式</span></span><br><span class="line"><span class="attr">a</span>: <span class="variable language_">console</span>.<span class="property">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 是绑定标识符</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// id是普通标识符</span></span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// id是普通标识符</span></span><br><span class="line">obj.<span class="property">id</span></span><br></pre></td></tr></table></figure>

<p>标识符的类型是根据 ECMAScript 规范定义的语法形式确定的，针对具体代码可以查询规范确定。</p>
<p>不同的标识符类型对于合法的标识符名称的要求不同，通过 Javascript 语法规则和静态语意进行约束。</p>
<p>下文中的“能&#x2F;不能作为标识符”、“合法标识符”等表述，如无特殊说明其中“标识符”均指<strong>绑定标识符、引用标识符和标签标识符</strong>，普通标识符的名称没有特殊要求，可以使用符合标识符名称的任意内容。</p>
<h1 id="合法标识符"><a href="#合法标识符" class="headerlink" title="合法标识符"></a>合法标识符</h1><h2 id="是关键字但不是保留字"><a href="#是关键字但不是保留字" class="headerlink" title="是关键字但不是保留字"></a>是关键字但不是保留字</h2><p>一部分关键字不是保留字，可以作为合法标识符使用，下面对属于这个分类的情况分别给出代码示例。</p>
<p>模块导入导出语法中的关键字<code>from</code>&#x2F;<code>as</code>可以作为标识符使用，因此下面的代码是合法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将模块导出到标识符from上，第一个from是标识符，第二个from是关键字</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">from</span> <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;from: &#x27;</span>, <span class="keyword">from</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将readFile导入为as变量，第一个as是关键字，第二个as是标识符</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile <span class="keyword">as</span> <span class="keyword">as</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;as: &#x27;</span>, <span class="keyword">as</span>)</span><br></pre></td></tr></table></figure>

<p>异步函数语法中<code>async</code>关键字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名称为 async的异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>for-of</code>循环中的<code>of</code>关键字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将循环变量命名为of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">of</span> <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">of</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象语法中 get&#x2F;set 属性或者类定义中 get&#x2F;set 方法使用到的关键字<code>get</code>&#x2F;<code>set</code>。</p>
<p>对象属性中用到名称为<code>get</code>&#x2F;<code>set</code>的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> get = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>) &#123;</span><br><span class="line">      set = value</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中定义名称为 get 的<code>get</code>属性和名称为 set 的<code>set</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;get&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set: &#x27;</span>, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">get</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">set</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Test</span>().<span class="title function_">print</span>()</span><br></pre></td></tr></table></figure>

<p><code>new.target</code>语法中的<code>target</code>关键字可以作为标识符，<code>new</code>是保留字不能作为标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">new</span>.<span class="property">target</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;target: &#x27;</span>, target)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Test</span>()</span><br></pre></td></tr></table></figure>

<p><code>import.meta</code>中的<code>meta</code>关键字作为合法的标识符，<code>import</code>是保留字不能作为标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> meta = <span class="keyword">import</span>.<span class="property">meta</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;meta: &#x27;</span>, meta)</span><br></pre></td></tr></table></figure>

<p>上述这些代码示例虽然合法，但是这种写法容易造成误解，实际编码过程中最好<strong>禁用</strong>这种写法。</p>
<h2 id="严格模式保留字"><a href="#严格模式保留字" class="headerlink" title="严格模式保留字"></a>严格模式保留字</h2><p>严格模式下以下列表中的标识符名称也是保留字，不能作为合法标识符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public</span><br><span class="line">private</span><br><span class="line">protected</span><br><span class="line">interface</span><br><span class="line">package</span><br><span class="line">implements</span><br><span class="line">let</span><br><span class="line">static</span><br><span class="line">yield // 下文有单独讨论</span><br></pre></td></tr></table></figure>

<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>yield 关键字在非严格模式下可以作为合法标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确，非严格模式</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">yield</span> = &#123; <span class="attr">yield</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">yield</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>.<span class="property">yield</span>)</span><br></pre></td></tr></table></figure>

<p>但是<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-identifiers-static-semantics-early-errors">静态语意</a>规定<strong>严格模式</strong>下 yield 是保留字，不能作为标识符。</p>
<p>使用’use strict’开启严格模式，下面代码中所有 yield 标识符都是非法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">yield</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">yield</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>)</span><br></pre></td></tr></table></figure>

<p>但是对象属性的标识符是普通标识符，所以名称为 yield 是合法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">yield</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">yield</span>)</span><br></pre></td></tr></table></figure>

<p>模块代码（Module）中自动开启严格模式，下面的代码是模块代码，<code>yield</code>是保留字，所以定义名称为<code>yield</code>的变量报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError: Unexpected strict mode reserved word</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">yield</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Generator 函数</strong>中不允许使用名称为 yield 关键字的<strong>绑定标识符</strong>，非 Generator 函数中无此限制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">yieldIsValidIdentifier</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 普通函数中合法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">yield</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">yieldIsUnexpectedIdentifier</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// SyntaxError: Unexpected identifier</span></span><br><span class="line">  <span class="comment">// 迭代器函数中非法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">yield</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外 Generator 函数中不允许以<strong>转义序列</strong>形式出现名称为 yield 的绑定标识符、引用标识符和标签标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// yield 转义形式</span></span><br><span class="line">  yiel\u&#123;<span class="number">64</span>&#125;: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="await"><a href="#await" class="headerlink" title="await "></a>await <span id="async-await"></span></h2><p>await 关键字在脚本（Script）环境中可以作为合法的标识符，严格模式对 await 是否是保留字<strong>无影响</strong>。下面脚本代码中的 await 都是合法标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">await</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">await</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">await</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">await</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">await</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>模块代码</strong>中 await 是保留字，不能用做标识符，下面的代码是<strong>模块代码</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 非法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">await</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">await</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 非法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">await</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>异步函数</strong>中 await 是保留字，不能用做标识符，下面的代码是<strong>脚本代码</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 合法</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">await</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法，异步函数的函数名不属于函数内部</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">await</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// SyntaxError: Unexpected reserved word</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">await</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在异步函数中同样也不允许以<strong>转义序列</strong>形式出现名称为 await 的绑定标识符、引用标识符和标签标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// SyntaxError: Keyword must not contain escaped characters</span></span><br><span class="line">  \u&#123;<span class="number">61</span>&#125;<span class="attr">wait</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="yield-x2F-await-存疑问题"><a href="#yield-x2F-await-存疑问题" class="headerlink" title="yield&#x2F;await 存疑问题"></a>yield&#x2F;await 存疑问题</h2><p>规范中关于 yield&#x2F;await<a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-identifiers-static-semantics-early-errors">部分</a>有个问题暂时没搞明白。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 规则1</span><br><span class="line">BindingIdentifier[Yield, Await] : yield</span><br><span class="line">  It is a Syntax Error if this production has a [Yield] parameter.</span><br><span class="line"></span><br><span class="line">// 规则2</span><br><span class="line">BindingIdentifier[Yield, Await] : await</span><br><span class="line">  It is a Syntax Error if this production has an [Await] parameter.</span><br><span class="line"></span><br><span class="line">// 规则3</span><br><span class="line">IdentifierReference[Yield, Await] : Identifier</span><br><span class="line">BindingIdentifier[Yield, Await] : Identifier</span><br><span class="line">LabelIdentifier[Yield, Await] : Identifier</span><br><span class="line">  It is a Syntax Error if this production has a [Yield] parameter and StringValue of Identifier is &quot;yield&quot;.</span><br><span class="line">  It is a Syntax Error if this production has an [Await] parameter and StringValue of Identifier is &quot;await&quot;.</span><br></pre></td></tr></table></figure>

<p>规则 3 的情况似乎覆盖了规则 1 和规则 2，为什么规则 1 和规则 2 需要单独表述？ （TODO:）</p>
<p>如果有人知道这个问题或者有兴趣交流，可以联系<a href="/about">我</a>。</p>
<h2 id="eval-x2F-arguments"><a href="#eval-x2F-arguments" class="headerlink" title="eval&#x2F;arguments"></a>eval&#x2F;arguments</h2><p>非严格模式下关键字 eval&#x2F;arguments 可以作为合法标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">eval</span>)</span><br></pre></td></tr></table></figure>

<p>严格模式下不 eval&#x2F;arguments 虽然不是保留字，但是也不允许作为<strong>绑定标识符</strong>，也就是不能作为变量名、函数名、类型名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eval</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但是作为其他类型标识符是合法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标签标识符 引用标识符</span></span><br><span class="line"><span class="attr">eval</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">eval</span>)</span><br></pre></td></tr></table></figure>

<p>arguments 关键字的情况类似。</p>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p><code>true</code>、<code>false</code>、<code>null</code>是保留字，不能作为标识符。<code>undefined</code>的情况比较特殊，它是一个合法标识符，不是<strong>关键字</strong>。Javascript 引擎初始化时在全局对象上初始化了名称为<code>undefined</code>的属性，值也是<code>undefined</code>，所以可以直接使用<code>undefined</code>变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>全局环境的<code>undefined</code>属性是不能重新<strong>赋值</strong>的，属性配置<code>configurable: false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> originalValue = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局undefined赋值不生效</span></span><br><span class="line"><span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalValue)</span><br><span class="line"><span class="comment">// undefined 值没有变化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>但是可以重新定义的方式来覆盖全局<code>undefined</code>属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> originalValue = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新定义</span></span><br><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalValue)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>函数内部的局部变量<code>undefined</code>就可以正常修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalUndefined = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">localUndefinedIsMutable</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="literal">undefined</span> = globalUndefined</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> originalValue = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 局部变量undefined赋值生效</span></span><br><span class="line">  <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(originalValue)</span><br><span class="line">  <span class="comment">// 1 值发生变化</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">localUndefinedIsMutable</span>()</span><br></pre></td></tr></table></figure>

<p>由于存在上述的情况，所以代码中直接使用<code>undefined</code>变量时得到的值不一定是<code>undefined</code>。为了保证拿到<code>undefined</code>值，常见用方式是使用 <a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-void-operator">void 表达式</a>。<code>void expr</code>对表达式 expr 进行求值，然后返回<code>undefined</code>值，expr 可能包含副作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let 在<strong>非严格模式</strong>下不是保留字，因此下面的形式是正确的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">let</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="keyword">let</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">let</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;let: &#x27;</span>, <span class="keyword">let</span>)</span><br></pre></td></tr></table></figure>

<p>但是<a href="https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-let-and-const-declarations-static-semantics-early-errors">LexicalDeclaration</a>语句和<a href="https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-for-in-and-for-of-statements-static-semantics-early-errors">ForInOfStatement</a>中不允许<code>let</code>作为绑定名称（<a href="https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-boundnames">BoundNames</a>）。</p>
<p>下面代码中名为<code>let</code>变量的声明都是非法的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError: let is disallowed as a lexically bound name</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">let</span> <span class="keyword">in</span> &#123;&#125;) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">let</span> <span class="keyword">in</span> &#123;&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">let</span> <span class="keyword">of</span> []) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">let</span> <span class="keyword">of</span> []) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> <span class="keyword">let</span> <span class="keyword">of</span> []) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> <span class="keyword">let</span> <span class="keyword">of</span> []) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>严格模式下声明名称为<code>let</code>的变量同样报错，但是注意报错原因和非严格模式不相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError: Unexpected strict mode reserved word</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">let</span> <span class="keyword">in</span> &#123;&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>既然<code>let</code>有这些额外的规定，那么<code>const</code>是不是也应该同样规定不能作为绑定名称呢？</p>
<p>查看规范原文，可以看到只对 let 做了表述。</p>
<blockquote>
<p>It is a Syntax Error if the BoundNames of ForDeclaration contains “let”.</p>
</blockquote>
<p>原因在于 const 永远是保留字，不像 let 一样只在严格模式下才是保留字，所以使用 const 作为标识符属于语法错误，在语法解析时就会报错，不需要额外规定。</p>
<h2 id="PrivateIdentifier"><a href="#PrivateIdentifier" class="headerlink" title="PrivateIdentifier"></a>PrivateIdentifier</h2><p>参考<a href="https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions-static-semantics-early-errors">规范</a></p>
<h2 id="禁用转义序列的非标准行为"><a href="#禁用转义序列的非标准行为" class="headerlink" title="禁用转义序列的非标准行为"></a>禁用转义序列的非标准行为</h2><p>ES6 之前主流的 Javascript 引擎实际上都支持使用保留字作为标识符，只要保留字中包含至少一个转义字符，这是<a href="https://mathiasbynens.be/notes/javascript-identifiers-es6#non-standard">非标准行为</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Invalid in ES5 and ES2015</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invalid in ES5 and ES2015, but supported in old ES5 engines:</span></span><br><span class="line"><span class="keyword">var</span> v\u0061r;</span><br></pre></td></tr></table></figure>

<p>但是 ES6 规范明确禁止了这种形式，规定关键字和标识符对于转义序列的使用有差别。<strong>关键字</strong>中不允许使用转义序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let &#123;&#125; = &#123;&#125;;</span></span><br><span class="line"><span class="comment">// \u&#123;6C&#125; 是 &#x27;l&#x27; 的转义序列</span></span><br><span class="line">\u&#123;6C&#125;et &#123;&#125;  = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上面将 let 使用了转义序列表示，所以代码解析的时候\u{6C}et 被当成标识符而不是关键字，后续语法解析会报错。</p>
<p>Node 环境运行会给出如下报错信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\u&#123;6C&#125;et &#123;&#125;  = &#123;&#125;;</span><br><span class="line">         ^</span><br><span class="line">SyntaxError: Unexpected token &#x27;&#123;&#x27;</span><br></pre></td></tr></table></figure>

<p>Typescript 的解析和提示更智能，会提示关键字中不能使用转义序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Keywords cannot contain escape characters.ts(1260)</span><br></pre></td></tr></table></figure>

<p><strong>标识符</strong>中可以使用转义序列，下面两种形式都声明了名称为 let 的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var let = 1;</span><br><span class="line">var \u&#123;6C&#125;et = 1;</span><br></pre></td></tr></table></figure>

<p>标识符中不允许以转义序列的形式出现保留字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非法，语法解析阶段报错</span></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token &#x27;const&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">const</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转义形式出现也非法，静态语意报错</span></span><br><span class="line"><span class="comment">// SyntaxError: Keyword must not contain escaped characters</span></span><br><span class="line"><span class="keyword">var</span> \u&#123;<span class="number">63</span>&#125;onst = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h1><h2 id="保留字判断"><a href="#保留字判断" class="headerlink" title="保留字判断"></a>保留字判断</h2><p>判断一个名称是否为合法的保留字受到严格模式和是否作为绑定标识符两个条件影响，<a href="https://github.com/babel/babel/blob/main/packages/babel-helper-validator-identifier/src/keyword.ts">Babel</a>提供了四个相关的工具函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非严格模式下word是不是保留字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isReservedWord</span>(<span class="params">word: string, inModule: boolean</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> (inModule &amp;&amp; word === <span class="string">&#x27;await&#x27;</span>) || word === <span class="string">&#x27;enum&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 严格模式下word是不是保留字，相比于非严格模式多了几个保留字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isStrictReservedWord</span>(<span class="params">word: string, inModule: boolean</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isReservedWord</span>(word, inModule) || reservedWordsStrictSet.<span class="title function_">has</span>(word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 严格模式下只针对绑定标识符形式来word说是保留字</span></span><br><span class="line"><span class="comment"> * 也就是word可以作为标识符引用、标签标识符等形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isStrictBindOnlyReservedWord</span>(<span class="params">word: string</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> reservedWordsStrictBindSet.<span class="title function_">has</span>(word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 严格模式下word是不是保留字，包括所有可能的保留字情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isStrictBindReservedWord</span>(<span class="params"></span></span><br><span class="line"><span class="params">  word: string,</span></span><br><span class="line"><span class="params">  inModule: boolean</span></span><br><span class="line"><span class="params"></span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="title function_">isStrictReservedWord</span>(word, inModule) || <span class="title function_">isStrictBindOnlyReservedWord</span>(word)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合法标识符判断"><a href="#合法标识符判断" class="headerlink" title="合法标识符判断"></a>合法标识符判断</h2><p><a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isValidIdentifier.ts">isValidIdentifier</a>判断名称 name 是否是合法标识符，reserved 为 true 表示排除保留字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">isValidIdentifier</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name: string,</span></span><br><span class="line"><span class="params">  reserved: boolean = <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span>): boolean &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name !== <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (reserved) &#123;</span><br><span class="line">    <span class="comment">// &quot;await&quot; is invalid in module, valid in script; better be safe (see #4952)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isKeyword</span>(name) || <span class="title function_">isStrictReservedWord</span>(name, <span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isIdentifierName</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isValidES3Identifier.ts">isValidES3Identifier</a>判断 name 是否是合法的 ES3 标识符，相比于<code>isValidIdentifier</code>排除了 ES3 中规定的标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">isValidES3Identifier</span>(<span class="params">name: string</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isValidIdentifier</span>(name) &amp;&amp; !<span class="variable constant_">RESERVED_WORDS_ES3_ONLY</span>.<span class="title function_">has</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换合法标识符"><a href="#转换合法标识符" class="headerlink" title="转换合法标识符"></a>转换合法标识符</h2><p><a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/converters/toIdentifier.ts">toIdentifier</a>将字符串转换为驼峰形式的合法标识符名称，排除可能的保留字形式，可能需要以<code>_</code>开头。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">toIdentifier</span>(<span class="params">input: string</span>): string &#123;</span><br><span class="line">  input = input + <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// replace all non-valid identifiers with dashes</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> input) &#123;</span><br><span class="line">    name += <span class="title function_">isIdentifierChar</span>(c.<span class="title function_">codePointAt</span>(<span class="number">0</span>)) ? c : <span class="string">&#x27;-&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove all dashes and numbers from start of name</span></span><br><span class="line">  name = name.<span class="title function_">replace</span>(<span class="regexp">/^[-0-9]+/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// camel case</span></span><br><span class="line">  name = name.<span class="title function_">replace</span>(<span class="regexp">/[-\s]+(.)?/g</span>, <span class="keyword">function</span> (<span class="params">match, c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c ? c.<span class="title function_">toUpperCase</span>() : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isValidIdentifier</span>(name)) &#123;</span><br><span class="line">    name = <span class="string">`_<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name || <span class="string">&#x27;_&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/converters/toBindingIdentifierName.ts">toBindingIdentifierName</a>将字符串转换为合法的绑定标识符名称，在<code>toIdentifier</code>的基础上再排除<code>eval</code>和<code>arguments</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">toBindingIdentifierName</span>(<span class="params">name: string</span>): string &#123;</span><br><span class="line">  name = <span class="title function_">toIdentifier</span>(name)</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;eval&#x27;</span> || name === <span class="string">&#x27;arguments&#x27;</span>) name = <span class="string">&#x27;_&#x27;</span> + name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol>
<li><p>Javascript 和 C 语言在合法标识符名称形式上有什么区别？</p>
</li>
<li><p>解释标识符名称、标识符、关键字、保留字这些概念，它们之间有什么联系和区别？</p>
</li>
<li><p>这段代码的含义是什么，为什么可以这样写？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 求和(...数列) &#123;</span><br><span class="line">  return 数列.reduce((和, 数) =&gt; 数 + 和, 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(求和(1, 2, 3))</span><br></pre></td></tr></table></figure>
</li>
<li><p>这段代码正确么，运行结果是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var \u&#123;12&#125; = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>这段代码会能正确运行么，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">var \u&#123;61&#125; = 2</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure></li>
<li><p>给一个字符串<code>input</code>如何获得对应的码点序列数组？</p>
</li>
<li><p>这段代码会能正确运行么，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">let \u&#123;61&#125; = 2</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这段代码正确么，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var private = 2</span><br><span class="line">console.log(private)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这段代码正确么，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">var private = 2</span><br><span class="line">console.log(private)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这段代码运行结果如何，为什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">from</span> <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;from: &#x27;</span>, <span class="keyword">from</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码能按预期打印 1 么？不能的话如何修改？两个’eval’有什么区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(&#x27;use strict; var eval = 1; console.log(eval)&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>yield 和 await 什么时候可以作为标识符，什么情况下作为关键字？</p>
</li>
<li><p>这段代码正确么，为什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> \u&#123;<span class="number">63</span>&#125;onst = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>undefined 相关</p>
<ol>
<li><code>undefined</code>是关键字还是标识符？</li>
<li><code>&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;</code>为什么可以这样写？</li>
<li><code>undefined === void 0</code>的值总是<code>true</code>么？</li>
<li><code>null</code>和<code>undefined</code>有什么区别？</li>
</ol>
</li>
<li><p>如何判断名称 name 是否是保留字？</p>
</li>
<li><p>如何判断名称 name 是合法标识符？</p>
</li>
<li><p>给一个字符串 name，如何将其转换成合法的标识符。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本文的相关参考资料，罗列如下。</p>
<p>可以首先阅读 <a href="https://mathiasbynens.be/notes/javascript-identifiers-es6">Valid JavaScript variable names in ES2015</a>，Mathias Byens 总结了 ES5 和 ES6 规范对于合法标识符名称的不同规定，从中可以了解到规范的演变过程。</p>
<p><a href="https://262.ecma-international.org/6.0/#sec-names-and-keywords">ES 2015 Names and Keywords</a>、<a href="https://tc39.es/ecma262/#sec-names-and-keywords">ES 2022 Names and Keywords</a>、<br><a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-identifiers-static-semantics-early-errors">ES 2022 Identifiers Static Semantics Early Errors</a>等 ECMAScript 规范内容是本文主要来源。</p>
<p>另外参考了 Babel 中标识符 <a href="https://github.com/babel/babel/tree/main/packages/babel-types/src/validators">validators</a>和 <a href="https://github.com/babel/babel/tree/main/packages/babel-types/src/converters">converters</a> 源码。</p>
]]></content>
      <categories>
        <category>深入理解Javascript</category>
      </categories>
      <tags>
        <tag>ECMAScript</tag>
        <tag>Unicode</tag>
        <tag>IdentifierName</tag>
        <tag>标识符名称</tag>
        <tag>Identifier</tag>
        <tag>标识符</tag>
        <tag>ReservedWord</tag>
        <tag>保留字</tag>
        <tag>Keyword</tag>
        <tag>关键字</tag>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>编码</title>
    <url>/2022/03/06/misc/encoding/</url>
    <content><![CDATA[<h1 id="ASCII-and-ISO-8859-1"><a href="#ASCII-and-ISO-8859-1" class="headerlink" title="ASCII and ISO-8859-1"></a>ASCII and ISO-8859-1</h1><p>ASCII 全称为 <strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange(美国标准信息交换码), 字符集中每个字符使用 7 个二进制位(bit)表示, 因此能够表示 128 个字符. 其中有 0 ~ 31 与 127 总共 33 个控制字符(control character), 32 ~ 126 包括空格(32), 字母, 数字以及英文标点符号.</p>
<p><img data-src="/images/ascii.png" alt="ascii"></p>
<p>ISO-8859-1 字符集对 ASCII 字符进行扩展, 将最高位利用起来, 使用 8 位表示一个字符. 但是新增的 128 字符中前 32 个(0x80 - 0x9F)与 ASCII 类似进行保留, 因此只增加了 96 个字符, 主要是有重音(diacritics)符号的拉丁文, 因此又被称为 Latin-1 字符集.</p>
<p><img data-src="/images/latin1.png" alt="latin1"></p>
<h1 id="Code-Page"><a href="#Code-Page" class="headerlink" title="Code Page"></a>Code Page</h1><p>为了支持英语以外的语言文字, Windows 系统采取了代码页(<a href="https://en.wikipedia.org/wiki/Code_page">Code Page</a>)的方案. 每个代码页是一个类似 ISO-8895-1 的编码方案, 对应为某个国家或者地区的文字, 在 0 ~ 127 的范围内和 ASCII 兼容, 在 128 ~ 255 的范围内为对应区域的文字编码.</p>
<p>不同语言 Windows 的系统默认使用不同的代码也来支持相应语言文字. Windows 系统内有两类代码页 ANSI 和 OEM 代码页. ANSI 代码页应用于 Window 桌面应用程序, 代码范围为 874 ~ 1258. OEM 代码页最初有 IBM 设计, 应用于 Windows console 中, 代码范围 437 ~ 874.</p>
<p>但是这样的代码页还是使用单字节来表示一个字符, 被称为单字节字符集(<a href="https://en.wikipedia.org/wiki/SBCS"><strong>S</strong>ingle-<strong>B</strong>yte <strong>C</strong>haracter <strong>S</strong>et</a>). 单字节字符接对于英语等字符个数少于 256 个的语言是合适的, 但是无法表示中日韩等字符个数较多的亚洲国家的语言文字. 对应的出现了使用两个字节的双字节字符集(<a href="https://en.wikipedia.org/wiki/DBCS"><strong>D</strong>ouble-<strong>B</strong>yte <strong>C</strong>haracter <strong>S</strong>et</a>), 也被称作多字节字符集(<a href="https://en.wikipedia.org/wiki/Variable-width_encoding#MBCS">Multi-byte Character Set</a>).</p>
<table>
<thead>
<tr>
<th align="left">代码页</th>
<th>语言</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cp932</td>
<td>日文</td>
</tr>
<tr>
<td align="left">cp936</td>
<td>简体中文 GBK</td>
</tr>
<tr>
<td align="left">cp949</td>
<td>韩文</td>
</tr>
<tr>
<td align="left">cp950</td>
<td>繁体中文 Big5</td>
</tr>
<tr>
<td align="left">cp1252</td>
<td>法国</td>
</tr>
</tbody></table>
<p>在 Windows 系统 DOS 窗口下可以使用命令<code>chcp</code>来对代码页进行设置.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp        //不带参数调用查看当前代码页</span><br><span class="line">chcp 1252   //设置代码页为1252</span><br></pre></td></tr></table></figure>

<p>但是代码页对于多语言的支持还存在一个问题, 不同国家的语言文字不能混用, 因为同一个代码页只能对应一个国家的语言文字. 代码页的方式已经不推荐使用, 我们需要一个能够表示所有国家语言文字的字符集, 这就是 Unicode 字符集.</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>Unicode 字符集全称 Universal Coded Character Set (UCS), 1988 年 8 月 Joe Becker 发布了 Unicode 的第一个草稿, 他解释说 Unicode 的名字代表了 unique(唯一), unified(统一), universal(通用) 三个意思.</p>
<h2 id="码点"><a href="#码点" class="headerlink" title="码点"></a>码点</h2><p>Unicode 为每个字符提供唯一的编号, 叫做码点(Code Point). 下面是从<a href="https://en.wikipedia.org/wiki/Unicode">Wiki</a>上摘抄的简短说明:</p>
<blockquote>
<p>In text processing, Unicode takes the role of providing a unique <em>code point</em>—a <a href="https://en.wikipedia.org/wiki/Number">number</a>, not a glyph—for each character. In other words, Unicode represents a character in an abstract way and leaves the visual rendering (size, shape, <a href="https://en.wikipedia.org/wiki/Font">font</a>, or style) to other software, such as a <a href="https://en.wikipedia.org/wiki/Web_browser">web browser</a> or <a href="https://en.wikipedia.org/wiki/Word_processor">word processor</a>.</p>
</blockquote>
<p>Unicode 的码点表示为 U+[XX]XXXX, X 表示一个 16 进制数字. 码点有 4-6 位, 不足 4 位的码点高位用 0 补齐 4 位, 超过 4 为的码点不做处理, 例如 U+0048(4 位补 0), U+1D11E(5 位), U+10FFFF(6 位). Unicode 标准规定码点范围为 U+0000 ~ U+10FFFF, 因此最大可以表示 1114112 个字符.</p>
<p>为了方便管理码点被划分成 17 个平面, 每个平面都是 256×256 的表格, 可以表示 65536 个码点. 第一个平面 Plane 0 被称作基本多语言平面(<strong>B</strong>asic <strong>M</strong>ultilingual <strong>P</strong>lane ), 包括码点范围 U+0000 ~ U+FFFF. 第一个平面内的字符只需要两个字节即可进行编码, 这也是最初的 Unicode 标准的全部表示范围. 后来 Unicode 进行了扩展, 后面的 16 个平面被称作增补平面(<strong>S</strong>upplementary <strong>P</strong>lanes)，也被叫做 <a href="https://www.quora.com/Why-are-unicode-characters-outside-the-BMP-called-astral">Astral Set</a>。</p>
<p>所有 Unicode 字符被划分为不同的类别(Categories), 每个类别还划分为若干个子类别, 具体列表如下:</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Subcategory</th>
</tr>
</thead>
<tbody><tr>
<td>Letter(L)</td>
<td>Lowercase(Ll), modifier(Lm), titlecase(Lt), uppercase(Lu), other(Lo)</td>
</tr>
<tr>
<td>Mark(M)</td>
<td>spacing combining(Mc), enclosing(Me), non-spacing(Mn)</td>
</tr>
<tr>
<td>Number(N)</td>
<td>decimal digit(Nd), letter(Nl), other(No)</td>
</tr>
<tr>
<td>Punctuation(P)</td>
<td>connector(Pc), dash(Pd), initial quote(Pi), final quote(Pf), open(Ps), close(Pe), other(Po)</td>
</tr>
<tr>
<td>Symbol(S)</td>
<td>currency(Sc), modifier(Sk), math(Sm), other(So)</td>
</tr>
<tr>
<td>Separator(Z)</td>
<td>line(Zl), paragraph(Zp), space(Zs)</td>
</tr>
<tr>
<td>Other()</td>
<td>Control(Cc), format(Cf), not assigned(Cn), private use(Co), surrogate(Cs)</td>
</tr>
</tbody></table>
<h2 id="Unicode-Equivalence"><a href="#Unicode-Equivalence" class="headerlink" title="Unicode Equivalence"></a>Unicode Equivalence</h2><p>Dynamic Composition</p>
<p>为了和已有标准相容, 某些被称为组合字符(<a href="https://en.wikipedia.org/wiki/Precomposed_character">precomposed character</a>)的特殊字符可以表示成两种形式, 单一的码点或者多个码点组成的序列, 这叫做 Unicode 等价性(<a href="https://en.wikipedia.org/wiki/Unicode_equivalence">unicode equivalence</a>). 常见的有带重音字符(<a href="https://en.wikipedia.org/wiki/Diacritic">diacritical mark</a>)字符和连字(<a href="https://en.wikipedia.org/wiki/Typographic_ligature">ligatures</a>). 例如:</p>
<ol>
<li>带重音符号字母 é 可以表示成单个字符 U+00E9(带有尖音符号的小写拉丁字符 e), 也可以表示成字符序列 U+0065(小写拉丁字母 e)和 U+0301(尖音符号).</li>
<li>单个字母 ff(小写拉丁连字 ff, U+FB00), 和两个连续的小写拉丁字母 f(U+0066U+0066)等价.</li>
</ol>
<p>Unicode 对于组合字符提供了两种等价概念: 标准等价(canonical equivalence)和相容等价(compatibility equivalence).</p>
<blockquote>
<p>Code point sequences that are defined as <strong>canonically equivalent</strong> are assumed to have the same appearance and meaning when printed or displayed.</p>
<p>符合标准等价一串字符序列在打印或者显示时具有<strong>相同的外观与功能</strong>.</p>
</blockquote>
<p>上面列举的带重音符号的字母的两种形式就是标准等价.</p>
<blockquote>
<p>Sequences that are defined as <strong>compatible</strong> are assumed to have possibly distinct appearances, but the same meaning in some contexts</p>
<p>相容等价的字符可能具有<strong>不同的外观</strong>, 但是所表示的字符是相同的.</p>
</blockquote>
<p>上面列举的连字的例子就属于相容等价.</p>
<p>为了判断组合字符的等价性, Unicode 规定了四种等价形式, 可以选择将字符或者字符序列转换成相同的形式来判断其等价性. 正规形式(normalization)及其算法如下表.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Algorithm</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NFD</strong> Normalization Form Canonical Decomposition</td>
<td>以标准等价方式来分解</td>
</tr>
<tr>
<td><strong>NFC</strong> Normalization Form Canonical Composition</td>
<td>以标准等价方式来分解，然后以标准等价重组之。若是 singleton 的话，重组结果有可能和分解前不同。</td>
</tr>
<tr>
<td><strong>NFKD</strong> Normalization Form Compatibility Decomposition</td>
<td>以相容等价方式来分解</td>
</tr>
<tr>
<td><strong>NFKC</strong> Normalization Form Compatibility Composition</td>
<td>以相容等价方式来分解，然后以标准等价重组之。</td>
</tr>
</tbody></table>
<p>详细的信息请参考<a href="https://en.wikipedia.org/wiki/Unicode_equivalence">wiki unicode equivalence</a>.</p>
<h2 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h2><p>UTF 全称 Unicode 转换格式(<strong>U</strong>CS <strong>T</strong>ransformation <strong>F</strong>ormat), Unicode 字符集只规定了字符对应的码点, 字符与码点是一对一的关系. UTF 为唯一的字符或者说码点提供在二进制位层面的编码方式, 具体包括 UTF-8, UTF-16 和 UTF-32.</p>
<p>ASCII 与 ISO-9985-1 等字符集只对应一种字符编码方式, 因此字符集(character set)与字符编码(character encoding)的概念不做区分. 但是 Unicode 字符集有三种字符编码 UTF-8&#x2F;UTF-16&#x2F;UTF-32, 每种字符编码使用不同的二进制数据代表同一个 Unicode 字符.</p>
<p>字符编码使用固定长度的代码单元(Code Unit)对字符进行编码, UTF-8, UTF-16 和 UTF-32 的代码单元分别是 8 位, 16 位和 32 位. 字符编码对字符集中所有字符进行编码时, 每个字符所需要的代码单元数目可能相同也可能不同. 所有字符需要的代码单元数目相同的编码方式被称为<strong>定长编码</strong>(fixed-width), 不同字符需要的代码单元数目不同的编码方式被称为<strong>变长编码</strong>(variable-width).</p>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="center">宽度</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">UTF-32</td>
<td align="center">定长</td>
<td align="left">使用一个代码单元(32 位)即可对所有 Unicode 字符进行编码, 高位用 0 补齐为 32 即可. 码点与编码字节内容一一对应. 这种编码方式优点在于查找效率高, 时间复杂度为<code>O(1)</code>, 缺点在于空间利用率低, 是相同内容的 ASCII 编码的四倍长度, 因此实践中较少使用.</td>
</tr>
<tr>
<td align="left">UTF-8</td>
<td align="center">变长</td>
<td align="left">使用 1 ~ 4 个代码单元(8 位)对 Unicode 字符进行编码, 字符搜索时间复杂度为<code>O(n)</code>, 但是编码效率比较高, 是网络传输及存储使用最多的编码方式</td>
</tr>
<tr>
<td align="left">UTF-16</td>
<td align="center">变长</td>
<td align="left">使用 1 ~ 2 个代码单元(16 位)对 Unicode 字符进行编码, 是 UTF-8 与 UTF-32 的折中方式, 内存操作效率比 UTF-8 高, 因此在程序中使用频繁.</td>
</tr>
<tr>
<td align="left">UCS-2</td>
<td align="center">定长</td>
<td align="left">早期 Unicode 提出的编码方式, 属于 UTF-16 的一个子集, 只能对 U+000 ~ U+FFFF 范围内的码点进行编码, 已废弃.</td>
</tr>
<tr>
<td align="left">UCS-4</td>
<td align="center">定长</td>
<td align="left">早期 Unicode 提出的编码方式, 功能上与 UTF-32 相同.</td>
</tr>
</tbody></table>
<p>UTF 编码还包括 UTF-1, UTF-7 和 UTF-EBCDIC 三种方式, 不是很常用, 详细信息可参考<a href="https://en.wikipedia.org/wiki/Unicode#cite_note-Glossary-5">Wiki</a>.</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a></h2><p>UTF-8 变长编码方案中一个字符编码长度可能为四种情况, 分别是 1,2,3,4 个字节. 具体的编码方式如下:</p>
<table>
<thead>
<tr>
<th align="center">编码长度(字节)</th>
<th>二进制编码</th>
<th align="center">有效位数</th>
<th align="center">码点范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>0XXXXXXX</code></td>
<td align="center">7</td>
<td align="center">U+0000 ~ U+007F</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>110XXXXX 10XXXXXX</code></td>
<td align="center">11</td>
<td align="center">U+0080 ~ U+07FF</td>
</tr>
<tr>
<td align="center">3</td>
<td><code>1110XXXX 10XXXXXX 10XXXXXX</code></td>
<td align="center">16</td>
<td align="center">U+0800 ~ U+FFFF</td>
</tr>
<tr>
<td align="center">4</td>
<td><code>11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</code></td>
<td align="center">21</td>
<td align="center">U+10000 ~ U+1FFFFF</td>
</tr>
</tbody></table>
<h3 id="编码方案讨论"><a href="#编码方案讨论" class="headerlink" title="编码方案讨论"></a>编码方案讨论</h3><p>UTF-8 编码中任意取出一个字节<code>xxxxxxxx</code>如果确定这个字节这个字节属于那种长度的编码? 不同长度的变长编码之间应该如何区分呢?</p>
<p>首先单字节编码与 ASCII 字符集兼容, 最高位为 0, 因此取出任意一个最高位为 0 的字节即可断定它属于单字节编码.</p>
<p>其次为了和单字节编码进行区分, 其余编码中每个字节最高位都必须为 1, 形如<code>1XXXXXXX</code>. 这时第二高位有 0 和 1 两种选择, 如果最高两位<code>10</code>和<code>11</code>的二进制编码都允许的话, 那么给定任意字节将无法在剩余三种编码中进行区分. 而且只能选择<code>10</code>作为区分标志. 后续 3, 4 字节编码如果想要区分只能增加 1 的个数, 如果选择<code>11</code>作为区分标志, 那么<code>11XXXXXX</code>与<code>111XXXXX</code>之间是无法区分的, 因为<code>11XXXXXX</code>中后六位为有效编码为, 其中的最高位既可以为 0 也可以为 1. 至此得到第二个正确的编码形式<code>10XXXXXX</code>, 后续只要增加前导 1 的个数即可在给定任意字节的情况下判定它属于 1, 2, 3, 4 字节变长编码的哪一种.</p>
<p>最后, 其实不需要做到给定任意单个字节即可判断其变长编码方式, 只需要在顺序解码的情况下, 能够区分连续的若干个字节属于那种编码方式即可. 最终的得到正式的 UTF-8 变长编方式, 复用了<code>10XXXXXX</code>的形式, 作为 2, 3, 4 字节编码中除去第一个字节外其余字节的编码形式, 同时第一个字节采用最高位增加 1 的个数的方法相互区分. 这样给定<code>10XXXXXX</code>形式的单个字节, 虽然无法判断它属于 2, 3, 4 字节编码中的哪一种, 但是对于连续字节流, 我们能够对区分 2, 3, 4 字节编码. 最终 2, 3, 4 字节编码第一个字节最高位分别以 2, 3, 4 个 1 后接一个 0 作为区分标志.</p>
<p>值得注意的是 4 字节编码最大码点为 U+1FFFFF, 因此 4 字节 UTF-8 编码就可以对 Unicode 规定的所有码点 U+0000 ~ U+10FFFF 进行编码. 起始最初的提案中还包括了 5, 6 字节编码, 但是 32 字节的 UTF-16 编码的最大码点就是 U+10FFFF, 因此正式标准去除了 5, 6 字节编码的部分. 5, 6 字节编码形式如下:</p>
<table>
<thead>
<tr>
<th align="center">编码长度</th>
<th>二进制编码</th>
<th align="center">有效位数</th>
<th align="center">码点范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td><code>111110XX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX</code></td>
<td align="center">26</td>
<td align="center">U+200000 ~ U+3FFFFFF</td>
</tr>
<tr>
<td align="center">6</td>
<td><code>1111110X 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX</code></td>
<td align="center">31</td>
<td align="center">U+4000000 ~ U+7FFFFFFF</td>
</tr>
</tbody></table>
<h3 id="编码范围与损耗"><a href="#编码范围与损耗" class="headerlink" title="编码范围与损耗"></a>编码范围与损耗</h3><p>Unicode 的码点范围就是 U+0000 ~ U+10FFFF, 四字节的 UTF-8 编码就已经足够对所有 Unicode 字符进行编码. 值得注意的是 2 字节编码 11 为有效位也能表示所有单字节 ASCII 字符, 于是 Unicode 规定对 ASCII 字符有限采用单字节编码, 因此 2 字节编码中的重复部分不对应任何编码. 如果在解码过程中遇到一个 2 字节编码的 ASCII 字符, 则意味着选择的编码方式不对. 类似的 3, 4 字节编码中也有一分部分二进制编码不对应任何字符.</p>
<h3 id="简体中文-UTF-8-编码示例"><a href="#简体中文-UTF-8-编码示例" class="headerlink" title="简体中文 UTF-8 编码示例"></a>简体中文 UTF-8 编码示例</h3><p>对于一个具体字符’你’(U+4F60), UTF-8 编码的过程如下:</p>
<ol>
<li>判断码点 U+4F60 位于 U+0800 ~ U+FFFF 范围内, 应该采用 3 字节编码.</li>
<li>码点的二进制形式为<code>0100 1111 0110 0000</code>, 三字节编码方式<code>1110XXXX 10XXXXXX 10XXXXXX</code>, 替换有效编码 X, 得到二进制编码<code>1110-0100 10-111101 10-10 0000</code>.</li>
<li>将二进制字节编码形式重新转换成 16 进制编码得到<code>E4 BD A0</code>, 这就是’你’的 UTF-8 编码.</li>
</ol>
<p>由于大多数简体中文汉字位于 U+0800 ~ U+FFFF 范围内均采用 3 字节编码, 第一字节最高四位固定为<code>1110</code>,对应的 16 进制编是<code>E</code>, 因此大多数简体汉字 UTF-8 编码 16 进制形式如<code>EX XX XX</code>.</p>
<h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16 是一种变长 2 或 4 字节编码方式, 1 个代码单元(Code Unit)为 2 字节, 也就是采用 1 或 2 个代码单元进行编码. 对于码点范围 U+0000 ~ U+FFFF 的基本平面(BMP)内的所有字符, UTF-16 采用 2 个字节即可进行编码. 对与码点范围 U+10000 ~ U+10FFFF 的增补平面(SP)内的码点, UTF-16 采用代理对(Surrogate Pair)进行编码.</p>
<h3 id="Surrogate-Pair"><a href="#Surrogate-Pair" class="headerlink" title="Surrogate Pair"></a>Surrogate Pair</h3><p>BMP 平面内最多可以表示 65536 个字符, 但是并不是平面上的每个格子都有对应的字符. 在 BMP 平面中有一片空白区域 U+D800 ~ U+DFFF 被称为代理区(Surrogate Area), 其中前半部分 U+D800 ~ U+DBFF 被称为高代理区(High Surrogate Area), 后半部分 U+DC00 ~ U+DFFFF 被称为低代理区(Low Surrogate Area). 从两个代理区中各取出一个码点即可组成一个代理对(Surrogate Pair).</p>
<p><img data-src="/images/surrogate_pair.png" alt="surrogate_pair"></p>
<p>每个代理区包含<code>4×256</code>个码点, 那么一个代理对可以表示 16 个增补平面中所有码点.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(4 * 256 ) * (4 * 256) = 16 * 65536</span><br></pre></td></tr></table></figure>

<p>代理对必须按照高代理对在前, 低代理对在后的方式顺序摆放才能代理一个码点. <code>D800 CD00</code>是第一个增补字符, <code>DBFF DFFF</code>是最后一个增补字符.</p>
<h3 id="Encoding-Process"><a href="#Encoding-Process" class="headerlink" title="Encoding Process"></a>Encoding Process</h3><p>BMP 平面内的码点直接对应于码点值相同的两个字节, 无需转换.</p>
<p>增补平面 SP 中的码点要算出对应的高低代理码点的值即可, 公式如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Lead = (CodePoint - 10000_&#123;16&#125;) / 1024 + D800</span><br><span class="line">Trail  = (CodePoint - 10000_&#123;16&#125;) / 1024 + DC00</span><br></pre></td></tr></table></figure>

<p>实际计算码点时不需要真的进行整数除法运算, 只需要进行一些移位操作即可.</p>
<h2 id="Byte-Order-BOM"><a href="#Byte-Order-BOM" class="headerlink" title="Byte Order BOM"></a>Byte Order BOM</h2><p>在 UTF-16 和 UTF-32 等编码方式中, 一个代码单元包括 2 或 4 个字节, 这就产生了一个字节存储顺序(<a href="https://en.wikipedia.org/wiki/Endianness">Endianness</a>)的问题. 大端序(Big Endian)存储将高位字节放在前边, 低位字节放在后边, 小端序(Small Endian)则相反.</p>
<blockquote>
<p>When storing a word in big-endian format the most significant byte, which is the byte containing the <a href="https://en.wikipedia.org/wiki/Most_significant_bit">most significant bit</a>, is stored first and the following bytes are stored in decreasing significance order, the least significant byte, which is the byte containing the <a href="https://en.wikipedia.org/wiki/Least_significant_bit">least significant bit</a>, thus being stored at last place.</p>
</blockquote>
<p>BOM 正是用来表示 UTF-16 和 UTF-32 的字节顺序, BOM 就是若干个特殊字节, 放在字节流的最前端, 用来表示字节顺序, 不同编码的字节序如下:</p>
<table>
<thead>
<tr>
<th>BOM</th>
<th>编码</th>
<th>字节序</th>
</tr>
</thead>
<tbody><tr>
<td>0x2B 0x2F 0x76 0x38 0x2D (5 个字节)</td>
<td>UTF-7</td>
<td>无</td>
</tr>
<tr>
<td>0xEF 0xBB 0xBF (3 个字节)</td>
<td>UTF-8</td>
<td>无</td>
</tr>
<tr>
<td>0xFF 0XFE (2 个字节)</td>
<td>UTF-16-LE</td>
<td>小端序</td>
</tr>
<tr>
<td>0xFE 0XFF (2 个字节)</td>
<td>UTF-16-BE</td>
<td>大端序</td>
</tr>
<tr>
<td>0xFF 0XFE 0x00 0x00 (4 个字节)</td>
<td>UTF-32-LE</td>
<td>小端序</td>
</tr>
<tr>
<td>0x00 0x00 0xFE 0XFF (4 个字节)</td>
<td>UTF-32-BE</td>
<td>大端序</td>
</tr>
</tbody></table>
<p>码点 U+FEFF 在 UTF-8 下的编码正是<code>EF BB BF</code>, 叫做零宽度非换行空格(zero-width non-breaking space), 缩写为<strong>ZWNBSP</strong>. 在屏幕上如字面意义一样显示一个宽度为零的空格, 结果就是什么也不显示. BOM 利用这一码点标识字节顺序.</p>
<p>Unicode 标准中规定 UTF-8 编码带不带 BOM 都可以,并且推荐不带 BOM 以便与 ASCII 兼容.Windows 系统下的 UTF-8 默认带有 BOM, 而 eclipse 中编辑器使用的 UTF-8 编码默认不带 BOM. UTF-8 编码的代码单元(Code Unit)只有一个字节(8bits), 因此并不存在端序的问题.不论 BOM 出现与否, UTF-8 编码的字节流都是一样的.</p>
<blockquote>
<p>The Unicode Standard allows that the BOM “can serve as signature for UTF-8 encoded text where the character set is unmarked”.<br>Windows 平台下 UTF-8 带有 BOM 仅方便确定其真实编码, 但是这种做法造成了两个文件直接合并后交界处多出一个 BOM 标志, 对于 Linux 平台下的工具十分不友好,因此 Linux 平台下使用的都是不带 BOM 的 UTF-8 编码.</p>
</blockquote>
<p>UTF-8 网络传输使用,内存操作使用 UTF-16.</p>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>在字符串(character string)到字节串(byte string)的编码(encoding)过程或者反向的解码(decoding)过程中, 由于使用不同的编码方案可能出现无法编码或者解码的错误情况. 对于这些情况可以选择以下不同的方式进行错误处理.</p>
<ol>
<li>严格模式, 抛出错误并停止编码解码.</li>
<li>忽略错误.</li>
<li>使用问号?(U+003F 或者 U+FFFD)替代.</li>
<li>使用相似的字形(<a href="https://en.wikipedia.org/wiki/Glyph">glyph</a>)替代.</li>
<li>使用转义(escape)字符替代.</li>
</ol>
<p>示例如下, 将 Unicode 字符串”abcdé”使用 ASCII 进行编码, 字符 é(U+00E9)无法编码.</p>
<table>
<thead>
<tr>
<th>Error handler</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>strict</td>
<td>raise an error</td>
</tr>
<tr>
<td>ignore</td>
<td><code>&quot;abcd&quot;</code></td>
</tr>
<tr>
<td>replace by ?</td>
<td><code>&quot;abcd?&quot;</code></td>
</tr>
<tr>
<td>replace by similiar glyph</td>
<td><code>&quot;abcde&quot;</code></td>
</tr>
<tr>
<td>escape as hexadecimal</td>
<td><code>&quot;abcd\xe9&quot;</code></td>
</tr>
<tr>
<td>escape as XML entities</td>
<td><code>&quot;abcd&amp;#233;&quot;</code></td>
</tr>
</tbody></table>
<h1 id="汉字编码"><a href="#汉字编码" class="headerlink" title="汉字编码"></a>汉字编码</h1><h2 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h2><blockquote>
<p>GB 2312-1980，全称《信息交换用汉字编码字符集 基本集》，由国家标准总局于 1980 年 3 月 9 号发布，1981 年 5 月 1 日实施，通行于大陆。新加坡等地也使用此编码。它是一个简化字的编码规范，也包括其他的符号、字母、日文假名等，共 7445 个图形字符，其中汉字占 6763 个。</p>
</blockquote>
<p><a href="http://my.oschina.net/goldenshaw/blog/352859">国栋</a>对于 GB2312 的说明:</p>
<blockquote>
<p>它是一个 94×94 的表格，理论上有 94×94&#x3D;8836 个空间。<br>横的叫区，竖的叫位，总共 94 个区，区和位的编号都从 1 开始。</p>
</blockquote>
<p>区位码</p>
<blockquote>
<p>所谓区位码就是这一 94×94 的大表格中的行号与列号了，均从 1 开始编号。<br>第一个字符 0101 为“全角空格”（图中显示为 SP（space））。</p>
</blockquote>
<p>国标码</p>
<blockquote>
<p>将区位码的区和位分别加上 32（&#x3D;0x20）就得到了国标码。GB2312 方案规定，对上述表中任意一个图形字符都采用两个字节表示，每个字节均采用七位编码表示。一字节有 128 个空间，128-32&#x3D;96，实际上，ASCII 中第 127 个也是控制码（DEL， 删除），再减去就还有 95 个有效位，再加上区位从 1 开始，又损失了一位，所以最终只有 94 个有效位了，这也是前面为何是一个 94×94 的表格。</p>
</blockquote>
<p>机内码</p>
<blockquote>
<p>将国标码高低字节分别加上 0x80（&#x3D;128）就得到了机内码（有时又叫交换码）。128 的二进制形式为 10000000，加 128，简单地讲，就是把国标码最高位置成 1. 就是要兼容 ASCII，ASCII 最高位为 0，国标码加 128 后，高低字节的最高位都成了 1，这样就与 ASCII 区分开来。</p>
</blockquote>
<h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><blockquote>
<p>GBK 是对 GB2312 的一个扩展，兼容 GB2312，因此也兼容 ASCII，也是一个变长编码方案。GBK 总体编码范围为 8140-FEFE，首字节在 81-FE 之间，尾字节在 40-FE 之间，总计 23940 个码位，共收入 21886 个汉字和图形符号，其中汉字（包括部首和构件）21003 个，图形符号 883 个。GBK 是国家有关部门与一些信息行业企业等一起合作推出的方案，但并未作为国家标准发布，只是一个事实上的标准，一个过渡方案，为 GB18030 标准作的一个准备。</p>
</blockquote>
<h1 id="缺省编码"><a href="#缺省编码" class="headerlink" title="缺省编码"></a>缺省编码</h1><p>Windows 与 Linux 平台下使用的默认编码并不相同, 因此同一文件在不同系统间会造成显示乱码的现象. Windows 系统下使用默认编码 ANSI(America Nantional Standards Institue), ANSI 并不指某个固定编码, 在 Win7 简体中文系统下 ANSI 就是 GBK 编码, 在港台地区可能是 Big5(繁体中文的一种编码方案), 在欧洲可能是(Latin-1). 即使都是简体中文系统, XP 和 Win7 的默认编码也肯能不一致.<br>Linux 系统下的默认编码都是不带 BOM 的 UTF-8 编码.<br>Windows 平台下的记事本编码比较坑爹, 如下图中显示有四种编码.<br><img data-src="/images/notepad_encoding.png" alt="notepad_encoding"><br>但是指代的具体编码却并不明显, 如下表, ANSI 默认为 GBK 编码, Unicode 实际上指的是, 与 Unicode big endian(UTF-16-BE)对应, 注意 UTF-16 都是带有 BOM 的, UTF-8</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>具体编码</th>
</tr>
</thead>
<tbody><tr>
<td>ANSI(默认编码)</td>
<td>简体中文 Win7 下为 GBK</td>
</tr>
<tr>
<td>Unicode</td>
<td>小端序 UTF-16</td>
</tr>
<tr>
<td>Unicode big endian</td>
<td>大端序 UTF-16</td>
</tr>
<tr>
<td>UTF-8</td>
<td>带 BOM 的 UTF-8</td>
</tr>
</tbody></table>
<p>记事本编码名称的随意造成了很多误解.</p>
<p>Windows 记事本乱码比较出名的一个例子跟”联通”有关. 使用默认编码新建一个文本文档, 其内容只有”联通”两个字, 之后重新打开记事本, 文本内容却变成了乱码”��ͨ”. 原因是”联通”在默认编码 GBK 下为</p>
<blockquote>
<p>C1 AA CD</p>
</blockquote>
<p>其二进制形式为</p>
<blockquote>
<p>1100001 10101010 11001101 10101000</p>
</blockquote>
<p>正好符合 UTF-8 编码的二字节编码</p>
<blockquote>
<p>110XXXXX 10XXXXXX</p>
</blockquote>
<p>因此被解码为</p>
<p><img data-src="/images/liantong.png" alt="liantong"></p>
<p>得到的码点为 U+006A, 这个码点在 U+0000 ~ U+007F 之间, UTF-8 对这个范围内的码点使用单字节编码. 因此二字节编码与 U+0000 ~ U+007F 范围对应的部分废弃掉了, 不对应任何字符. 因此这两个字节无法成功解码, 使用 Unicode 字符’�’代替.</p>
<p>虽然显示出现了乱码, 但是文件的内容并没有改变, 因此只需要使用 Vim 明确指定文件编码为 GBK 即可正确显示,下面设置首先使用 GBK 对文件解码.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set fileencodings=ucs-bom,gbk,utf-8,gb18030,big5,euc-jp,euc-kr,latin1</span><br></pre></td></tr></table></figure>

<p>另外还有一点值得注意, Win7 简体中文系统对<strong>文件内容</strong>默认采用 GBK 编码, 但是<strong>文件名称</strong>却是使用 UTF-16 编码, 因此可以使用上述 Unicode 字符’�’作为文件名称.</p>
<h1 id="指定编码"><a href="#指定编码" class="headerlink" title="指定编码"></a>指定编码</h1><p>有一些文件会在第一行或者前几行中指定文件编码, 如 xml&#x2F;html&#x2F;python&#x2F;ruby 等源文件.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<p>由于前几行都是 ASCII 字符, 这种策略首先使用 ASCII 对于文件进行解码, 获得指定的正确编码后在对文件重新解码.</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript 使用 UTF16 编码，没有字符类型，对于单个字符用内容相同的字符串表示。设计上对于字符串码点（Code Point）相关操作只提供<strong>常量时间</strong>的接口。</p>
<ol>
<li><code>str.charAt(index)</code> 返回下标<code>index</code>对应的代码单元（2 个字节)代表的单个字符形成的字符串，不考虑代理对因素。</li>
<li><code>str.charCodeAt(index)</code> 返回下标<code>index</code>对应的代码单元整数值 [0, 65536) 之间，不考虑代理对的因素。</li>
<li><code>str.codePointAt(index)</code> 返回下标<code>index</code>对应的字节处的字符码点，如果<code>index</code>位置开始的四个字节不是合法的代理对，直接返回<code>index</code>开始的两个字节对应的代码单元代表的码点。</li>
</ol>
<p>检查 UTF16 编码字节流是否合法，获取字符串中 Unicode 字符个数，获取字符串从左到右第几个 Unicode 字符等操作是线性时间操作，JavaScript 没有直接提供内置实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * find code point count in a string</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; str target string whose unicode character count will be returned</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> unicode character count of input string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getCodePointCount</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isSurrogatePairHigh</span>(<span class="params">code</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(code)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`code <span class="subst">$&#123;code&#125;</span> must be integer`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> code &gt;= <span class="number">0xd800</span> &amp;&amp; code &lt;= <span class="number">0xdbff</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isSurrogatePairLow</span>(<span class="params">code</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(code)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`code <span class="subst">$&#123;code&#125;</span> must be integer`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> code &gt;= <span class="number">0xdc00</span> &amp;&amp; code &lt;= <span class="number">0xdfff</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;str is not string&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; ) &#123;</span><br><span class="line">    <span class="keyword">const</span> charCode = str.<span class="title function_">charCodeAt</span>(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSurrogatePairHigh</span>(charCode)) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextCharCode = str.<span class="title function_">charCodeAt</span>(i + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(nextCharCode)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">          <span class="string">&#x27;[invalid utf16 sequence]: string ends in unpaired high surrogate&#x27;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isSurrogatePairLow</span>(nextCharCode)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">          <span class="string">`[invalid utf16 code sequence]: high surrogate pair not followed by low part, (<span class="subst">$&#123;charCode&#125;</span> at <span class="subst">$&#123;i&#125;</span> is high, <span class="subst">$&#123;nextCharCode&#125;</span> at <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            i + <span class="number">1</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          &#125;</span> is not low)`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">      i += <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSurrogatePairLow</span>(charCode)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">        <span class="string">`[invalid utf16 code sequence]: low surrogate pair <span class="subst">$&#123;charCode&#125;</span> at <span class="subst">$&#123;i&#125;</span> not preceded by high part`</span></span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找从左到右第几个 Code Point 实现可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt">mdn knownCharCodeAt</a>。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>C++11 之前, <code>wchar_t</code>类型对宽字符提供同支持, 但是标准并没有规定其实现, 因此<code>wchar_t</code>的具体类型与实现相关. 在 windows 平台下<code>whcar_t</code>是 2 个字节, 在 Linux 平台下是 4 个字节, 这种不一致性使得使用<code>wchar_t</code>的代码不具有移植性. 宽字符与字符串字面量(Wide-Character String Literal)使用 L 开头作为标志, 如下所示.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">wchar_t</span> wc = <span class="string">L&#x27;中&#x27;</span>;</span><br><span class="line"><span class="type">wchar_t</span> wc_array[] = <span class="string">L&quot;汉字&quot;</span>;</span><br><span class="line">std::wstring wstr = <span class="string">L&quot;汉字&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>U</strong>nicode <strong>S</strong>tring <strong>L</strong>iteral 是 C++11 对 Unicode 提供的语言级别的支持. C++11 新增字符类型<code>char16_t</code>(至少 16 位)和<code>char32_t</code>(至少 32 位)分别表示 UTF-16 和 UTF-32 编码的代码单元, Unicode 三种编码 UTF-8, UTF-16, UTF-32 对应的字符串字面量分别以 u8, u, U 前缀作为标志.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> u8char = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> u8char_array[] = <span class="string">u8&quot;\U0001F607 is O:-)&quot;</span>;</span><br><span class="line">std::string u8str   = <span class="string">u8&quot;\U0001F607 is O:-)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char16_t</span> u16char = <span class="string">u&#x27;😃&#x27;</span>;</span><br><span class="line"><span class="type">char16_t</span> u16char_array[] = <span class="string">u&quot;😃 = \U0001F603 is :-D&quot;</span>;</span><br><span class="line">std::u16string u16str    = <span class="string">u&quot;😃 = \U0001F603 is :-D&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char32_t</span> u32char = <span class="string">U&quot;😎&quot;</span>;</span><br><span class="line"><span class="type">char32_t</span> u32char_array[] = <span class="string">U&quot;😎 = \U0001F60E is B-)&quot;</span>;</span><br><span class="line">std::u32string u32str    = <span class="string">U&quot;😎 = \U0001F60E is B-)&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>Java 规定源代码默认用 UTF-16 编码, 其中 String 类的 length 方法说明如下:</p>
<blockquote>
<p>Returns the length of this string. The length is equal to the number of <a href="http://download.oracle.com/javase/7/docs/api/java/lang/Character.html#unicode">Unicode code units</a> in the string.</p>
<p>返回字符串的长度,这一长度等于字符串中 Unicode 代码单元的数目.</p>
</blockquote>
<p>由于 BMP 范围内的编码只需要一个代码单元就可以表示,因此由 BMP 范围内的字符组成的字符串,length 返回的长度和字符的个数一致. 超过 BMP 范围的字符, 每个需要两个代码单元进行编码,length 返回的长度与字符个数并不一致.</p>
<p>另外 Java 中 String 类的 getBytes()方法说明如下:</p>
<blockquote>
<p>Encodes this <code>String</code> into a sequence of bytes using the given <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html">charset</a>, storing the result into a new byte array.</p>
<p>使用指定编码方式将字符串进行编码,并将结果存入一个新的字节数组.</p>
</blockquote>
<p>不指定字符集时将使用默认的编码, JVM 默认的编码方式是 UTF-8, 这一点可以使用命令行参数控制.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javaw.exe -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>

<p>需要注意的是如果如果使用 UTF-16 编码, 得到的字节流中会包含 BOM, 结果字节流的长度比预期的要多 2 个字节.</p>
<h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a><a href="https://en.wikipedia.org/wiki/Base64">Base64</a></h1><blockquote>
<p><strong>Base64</strong> is a group of similar binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation</p>
</blockquote>
<p><strong>Base64</strong> encode binary data in a unit of 3 bytes, also 24 bits. If number of bytes is indivisible by 3, add extra bytes with value zero so there’re 3 bytes.</p>
<p>Encoding 3 bytes “Man”.</p>
<table style='border: 1px solid;'>
    <tr>
        <td style='border: 1px solid;'>source ASCII</td>
        <td style='border: 1px solid;' colspan='8' align='center'>M</td>
        <td style='border: 1px solid;' colspan='8' align='center'>a</td>
        <td style='border: 1px solid;' colspan='8' align='center'>n</td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>source octets</td>
        <td style='border: 1px solid;' colspan='8' align='center'>77 (0x4d)</td>
        <td style='border: 1px solid;' colspan='8' align='center'>97 (0x61)</td>
        <td style='border: 1px solid;' colspan='8' align='center'>110 (0x6e)</td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>Bit pattern</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>Table Index</td>
        <td style='border: 1px solid;' colspan='6' align='center'>19</td>
        <td style='border: 1px solid;' colspan='6' align='center'>22</td>
        <td style='border: 1px solid;' colspan='6' align='center'>5</td>
        <td style='border: 1px solid;' colspan='6' align='center'>46</td>
    </tr>
    <tr>
        <td>Encoded Char</td>
        <td style='border: 1px solid;' colspan='6' align='center'>T</td>
        <td style='border: 1px solid;' colspan='6' align='center'>W</td>
        <td style='border: 1px solid;' colspan='6' align='center'>F</td>
        <td style='border: 1px solid;' colspan='6' align='center'>u</td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>Encoded octets</td>
        <td style='border: 1px solid;' colspan='6' align='center'>84 (0x54)</td>
        <td colspan='6' align='center'>87 (0x57)</td>
        <td style='border: 1px solid;' colspan='6' align='center'>70 (0x46)</td>
        <td colspan='6' align='center'>117 (0x75)</td>
    </tr>
</table>

<p>Encoding 2 bytes “Ma”, last 6 bits are padding bits, encoded as “&#x3D;”.</p>
<table style='border: 1px solid;'>
    <tr>
        <td style='border: 1px solid;'>source ASCII</td>
        <td style='border: 1px solid;' colspan='8' align='center'>M</td>
        <td style='border: 1px solid;' colspan='8' align='center'>a</td>
        <td style='border: 1px solid;' colspan='8' align='center'></td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>source octets</td>
        <td style='border: 1px solid;' colspan='8' align='center'>77 (0x4d)</td>
        <td style='border: 1px solid;' colspan='8' align='center'>97 (0x61)</td>
        <td style='border: 1px solid;' colspan='8' align='center'>0 (0x00)</td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>Bit pattern</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>Table Index</td>
        <td style='border: 1px solid;' colspan='6' align='center'>19</td>
        <td style='border: 1px solid;' colspan='6' align='center'>22</td>
        <td style='border: 1px solid;' colspan='6' align='center'>4</td>
        <td style='border: 1px solid;' colspan='6' align='center'>0</td>
    </tr>
    <tr>
        <td>Encoded Char</td>
        <td style='border: 1px solid;' colspan='6' align='center'>T</td>
        <td style='border: 1px solid;' colspan='6' align='center'>W</td>
        <td style='border: 1px solid;' colspan='6' align='center'>E</td>
        <td style='border: 1px solid;' colspan='6' align='center'>=</td>
    </tr>
</table>

<p>Encoding 1 byte “M”, last 12 bits are padding bits, encoded as “&#x3D;&#x3D;”.</p>
<table style='border: 1px solid;'>
    <tr>
        <td style='border: 1px solid;'>source ASCII</td>
        <td style='border: 1px solid;' colspan='8' align='center'>M</td>
        <td style='border: 1px solid;' colspan='8' align='center'></td>
        <td style='border: 1px solid;' colspan='8' align='center'></td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>source octets</td>
        <td style='border: 1px solid;' colspan='8' align='center'>77 (0x4d)</td>
        <td style='border: 1px solid;' colspan='8' align='center'>0 (0x00)</td>
        <td style='border: 1px solid;' colspan='8' align='center'>0 (0x00)</td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>Bit pattern</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>1</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
        <td style='border: 1px solid;'>0</td>
    </tr>
    <tr>
        <td style='border: 1px solid;'>Table Index</td>
        <td style='border: 1px solid;' colspan='6' align='center'>19</td>
        <td style='border: 1px solid;' colspan='6' align='center'>16</td>
        <td style='border: 1px solid;' colspan='6' align='center'>0</td>
        <td style='border: 1px solid;' colspan='6' align='center'>0</td>
    </tr>
    <tr>
        <td>Encoded Char</td>
        <td style='border: 1px solid;' colspan='6' align='center'>T</td>
        <td style='border: 1px solid;' colspan='6' align='center'>Q</td>
        <td style='border: 1px solid;' colspan='6' align='center'>=</td>
        <td style='border: 1px solid;' colspan='6' align='center'>=</td>
    </tr>
</table>

<p>Base64 index table is used to encode 6 bits as ASCII character.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Char</th>
<th>Value</th>
<th>Char</th>
<th>Value</th>
<th>Char</th>
<th>Value</th>
<th>Char</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>16</td>
<td>Q</td>
<td>32</td>
<td>g</td>
<td>48</td>
<td>w</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>17</td>
<td>R</td>
<td>33</td>
<td>h</td>
<td>49</td>
<td>x</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>18</td>
<td>S</td>
<td>34</td>
<td>i</td>
<td>50</td>
<td>y</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>19</td>
<td>T</td>
<td>35</td>
<td>j</td>
<td>51</td>
<td>z</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>20</td>
<td>U</td>
<td>36</td>
<td>k</td>
<td>52</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>21</td>
<td>V</td>
<td>37</td>
<td>l</td>
<td>53</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>22</td>
<td>W</td>
<td>38</td>
<td>m</td>
<td>54</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>23</td>
<td>X</td>
<td>39</td>
<td>n</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>24</td>
<td>Y</td>
<td>40</td>
<td>o</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>25</td>
<td>Z</td>
<td>41</td>
<td>p</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>26</td>
<td>a</td>
<td>42</td>
<td>q</td>
<td>58</td>
<td>6</td>
</tr>
<tr>
<td>11</td>
<td>L</td>
<td>27</td>
<td>b</td>
<td>43</td>
<td>r</td>
<td>59</td>
<td>7</td>
</tr>
<tr>
<td>12</td>
<td>M</td>
<td>28</td>
<td>c</td>
<td>44</td>
<td>s</td>
<td>60</td>
<td>8</td>
</tr>
<tr>
<td>13</td>
<td>N</td>
<td>29</td>
<td>d</td>
<td>45</td>
<td>t</td>
<td>61</td>
<td>9</td>
</tr>
<tr>
<td>14</td>
<td>O</td>
<td>30</td>
<td>e</td>
<td>46</td>
<td>u</td>
<td>62</td>
<td>+</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
<td>31</td>
<td>f</td>
<td>47</td>
<td>v</td>
<td>63</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://my.oschina.net/goldenshaw/blog/304493?fromerr=ChUuZ0yx">字符集与编码系列博客 - 国栋</a></li>
<li><a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></li>
<li><a href="http://unicodebook.readthedocs.io/index.html">Unicode book</a></li>
<li>[UTF-8 and Unicode FAQ for Unix&#x2F;Linux](UTF-8 and Unicode FAQ for Unix&#x2F;Linux)</li>
<li><a href="http://blog.poxiao.me/p/unicode-character-encoding-conversion-in-cpp11/">破晓的博客 C+11 与 Unicode</a></li>
<li><a href="http://shop.oreilly.com/product/9780596101213.do">Unicode Explained</a></li>
<li><a href="http://shop.oreilly.com/product/9780596101213.do">The Unicode Standard</a></li>
<li>International Components for Unicode (ICU)</li>
<li><a href="http://www.boost.org/doc/libs/1_60_0/libs/locale/doc/html/index.html">Boost.Locale</a></li>
<li><a href="http://cppcms.com/files/nowide/html/">Boost.Nowide</a></li>
<li><a href="http://www.gnu.org/software/libiconv/">iconv</a></li>
<li><a href="http://utf8everywhere.org/">UTF8 everywhere</a></li>
<li><a href="http://programmers.stackexchange.com/questions/102205/should-utf-16-be-considered-harmful">Should UTF-16 be considered harmful?</a></li>
<li><a href="https://channel9.msdn.com/Events/CPP/C-PP-Con-2014/Unicode-in-CPP">Unicode in C++</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46216008">程序员必备：彻底弄懂常见的 7 种中文字符编码</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/41203455">从 Unicode 到 emoji</a></li>
<li><a href="https://stackoverflow.com/questions/43150498/how-to-get-all-unicode-characters-from-specific-categories">How to get all Unicode characters from specific categories?</a></li>
<li><a href="https://codepoints.net/">码点查询网站</a></li>
</ol>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
        <tag>Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象语法树</title>
    <url>/2022/03/06/babel/advanced/ast/</url>
    <content><![CDATA[<p>Javascript 代码经过解析得到抽象语法树（<strong>A</strong>bstract <strong>S</strong>yntax <strong>T</strong>ree），用来表示程序源码结构。</p>
<p>前端基础工具 Babel、ESLint、Prettier 等使用的 Javascript 抽象语法树最早是火狐的工程师开发 SpiderMonkey 引擎时使用的格式，后来发展为统一的<a href="https://github.com/estree/estree">ESTree 规范</a>，包含 ECMAScript 规范各版本对应的抽象语法树文档和一些废弃或者是提案语法的文档。</p>
<p>Babel 使用的抽象语法树规范参考<a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md">官方文档</a>。抽象语法树规范主要描述每种语法特性的树节点，主要包括文件（File）、程序（Program）、语句（Statement）、声明（Declaration）、表达式（Expression）和其他杂项类型。</p>
<p>使用网站<a href="https://astexplorer.net/">astexplorer</a>可以方便的查看任意 JS 代码抽象语法树结构。左边是源码，右边是对应的抽象语法树。</p>
<p><img data-src="/images/ast-explorer.png" alt="ast-explorer"></p>
<h1 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h1><p>下面使用 Babel 为例，来看看抽象语法树节点都包含哪些具体类型。</p>
<h2 id="基础节点类型"><a href="#基础节点类型" class="headerlink" title="基础节点类型"></a>基础节点类型</h2><p><code>BaseNode</code>对象是所有的抽象语法树节点的基础类型，不同的节点在<code>BaseNode</code>对象的基础上增加字段代表独有信息。<code>BaseNode</code>对象格式如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">BaseNode</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: string;</span><br><span class="line">  <span class="attr">loc</span>: <span class="title class_">SourceLocation</span> | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">start</span>: number | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">end</span>: number | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">leadingComments</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="title class_">Comment</span>&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">innerComments</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="title class_">Comment</span>&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">trailingComments</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="title class_">Comment</span>&gt; | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  range?: [number, number];</span><br><span class="line">  extra?: <span class="title class_">Record</span>&lt;string, unknown&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>type</code>字段是代表节点类型，不同节点根据类型字段进行区分。<code>loc</code>字段代表该节点在源码中的首尾行列位置信息，<code>start</code>和<code>end</code>代表该节点在源码中的字符下标位置，<code>range</code>字段以数组形式存储<code>[start, end]</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">SourceLocation</span> &#123;</span><br><span class="line">  <span class="attr">source</span>: string | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">start</span>: <span class="title class_">Position</span>;</span><br><span class="line">  <span class="attr">end</span>: <span class="title class_">Position</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Position</span> &#123;</span><br><span class="line">  <span class="attr">line</span>: number; <span class="comment">// &gt;= 1</span></span><br><span class="line">  <span class="attr">column</span>: number; <span class="comment">// &gt;= 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>leadingComments/innerComments/trailingComments</code>是节点前后的注释信息。<code>extra</code>字段存储额外的信息，例如括号表达式标志为<code>parenthesized</code>。</p>
<h2 id="File-amp-Program-amp-Directive"><a href="#File-amp-Program-amp-Directive" class="headerlink" title="File &amp; Program &amp; Directive"></a>File &amp; Program &amp; Directive</h2><h3 id="源码类型"><a href="#源码类型" class="headerlink" title="源码类型"></a>源码类型</h3><p>JS 抽象语法树根节点都是<code>File</code>类型，代表当前整个源码文件。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">BaseNode</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;File&#x27;</span></span><br><span class="line">  <span class="attr">program</span>: <span class="title class_">Program</span></span><br><span class="line">  comments?: <span class="title class_">Array</span>&lt;<span class="title class_">CommentBlock</span> | <span class="title class_">CommentLine</span>&gt; | <span class="literal">null</span></span><br><span class="line">  tokens?: <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt; | <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>File</code>节点下包含<code>Program</code>类型节点，是代码的根节点。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Program</span> <span class="keyword">extends</span> <span class="title class_">BaseNode</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;Program&#x27;</span></span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Statement</span>&gt;</span><br><span class="line">  <span class="attr">directives</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Directive</span>&gt;</span><br><span class="line">  <span class="attr">sourceType</span>: <span class="string">&#x27;script&#x27;</span> | <span class="string">&#x27;module&#x27;</span></span><br><span class="line">  interpreter?: <span class="title class_">InterpreterDirective</span> | <span class="literal">null</span></span><br><span class="line">  <span class="attr">sourceFile</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 引入模块机制之前，Javascript 的代码都是全局脚本（Script）类型。引入模块（Module）机制后为了与脚本进行区分，<code>Program</code>节点使用 <code>sourceType</code>字段表示分为脚本（Script）和模块（Module）两种。对于任意 JS 文件，如果包含导入导出（<code>import/export</code>）语句，可以确认是模块类型；如果不包含导入导出语句可能是模块类型，也可能是脚本类型。使用 Babel 解析代码时可以指定文件的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> parser <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`let a = 1;`</span></span><br><span class="line">parser.<span class="title function_">parse</span>(code, &#123; <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><code>sourceType</code>解析参数用来指定代码类型，有三个选项。</p>
<ol>
<li><code>module</code> - 指定代码是模块类型</li>
<li><code>script</code> - 指定代码是脚本类型，如果包含导入导出语句会<strong>抛出异常</strong>，默认值。</li>
<li><code>unambiguous</code> - 不指定类型，根据是否包含导入导出语句进行推测，不会抛出异常。</li>
</ol>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><code>Program</code>节点中包含<code>directives</code>字段代表<a href="https://262.ecma-international.org/6.0/#sec-directive-prologues-and-the-use-strict-directive">指令序言</a>（Directive Prologue），指全局或者函数内部最开始的若干个语句，这些语句的内容是字符串字面量的形式。这些语句合称为指令序言，其中每个语句称为指令（Directive），当前的规范中只规定了严格模式指令（Use Strict Directive）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> parser <span class="keyword">from</span> <span class="string">&#x27;@babel/parser&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = <span class="string">`&#x27;use strict&#x27;; let a = 1;`</span></span><br><span class="line"></span><br><span class="line">parser.<span class="title function_">parse</span>(script)</span><br></pre></td></tr></table></figure>

<p>指令序言中可能包含多条重复的严格模式指令，不属于语法错误，但是可以由给出警告。</p>
<p><code>Program</code>节点的<code>interpreter</code>字段是解释器指令（InterpreterDirective），用来代表 JS 文件作为 Shell 脚本命令运行时指定使用<code>node</code>作为解释器运行，这是 Unix 系统的<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">约定</a>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> parser <span class="keyword">from</span> <span class="string">&#x27;@babel/parser&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = <span class="string">`#!/usr/bin/env node &#x27;use strict&#x27;; let a = 1;`</span></span><br><span class="line"></span><br><span class="line">parser.<span class="title function_">parse</span>(script)</span><br></pre></td></tr></table></figure>

<p>注意解释器指令必须位于文件<strong>第一行</strong>，否则解析会报错。解释器指令属于 Babel 的扩展特性，不属于 ECMAScript 规范。</p>
<h2 id="语句（Statement）"><a href="#语句（Statement）" class="headerlink" title="语句（Statement）"></a>语句（Statement）</h2><p>语句是<code>Program</code>节点的子节点，常见的语句类型如下。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">// 只包含一个分号的空语句 EmptyStatement</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">// DebuggerStatement</span><br><span class="line">debugger</span><br><span class="line"></span><br><span class="line">// WithStatement</span><br><span class="line">with (a) &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 块语句 BlockStatement</span><br><span class="line">&#123;</span><br><span class="line">  let a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 流程控制语句</span><br><span class="line">return 1;</span><br><span class="line">label1: 1;</span><br><span class="line">break;</span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">// 分支语句</span><br><span class="line">if (a) &#123;&#125;</span><br><span class="line">switch (a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 异常语句</span><br><span class="line">try &#123; &#125; catch() &#123;&#125;</span><br><span class="line">throw e;</span><br><span class="line"></span><br><span class="line">// 循环语句</span><br><span class="line">while (true) &#123;&#125;</span><br><span class="line">do &#123;&#125; while (true)</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;&#125;</span><br><span class="line">for (const key in obj) &#123;&#125;</span><br><span class="line">for (const value of array) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外有两种特殊的语句，声明语句（Declaration）和表达式语句（ExpressionStatement）。表达式语句是由任意表达式组成的语句，可能的情况参考表达式类型。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>声明语句创建一个绑定标识符（Binding Identifier），包括变量（VariableDeclaration）、函数（FunctionDeclaration）、类（ClassDeclaration）、导入导出等情况。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">&#x27;math&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; math &#125;</span><br></pre></td></tr></table></figure>

<p>函数、类、导入也存在表达式的形式。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Test</span> = <span class="keyword">new</span> (<span class="keyword">class</span> &#123;&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="title function_">import</span>(<span class="string">&#x27;math&#x27;</span>).<span class="title function_">then</span>()</span><br></pre></td></tr></table></figure>

<h2 id="表达式（Expression）"><a href="#表达式（Expression）" class="headerlink" title="表达式（Expression）"></a>表达式（Expression）</h2><p>表达式类型包含了大部分抽象语法树节点类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnaryExpression</span></span><br><span class="line">!a</span><br><span class="line"><span class="comment">// BinaryExpression</span></span><br><span class="line">a + b</span><br><span class="line"><span class="comment">// LogicalExpression</span></span><br><span class="line">a &amp;&amp; b</span><br><span class="line"><span class="comment">// AssignmentExpression</span></span><br><span class="line">a = b</span><br><span class="line"><span class="comment">// ConditionalExpression</span></span><br><span class="line">a ? b : c</span><br><span class="line"><span class="comment">// MemberExpression</span></span><br><span class="line">a.<span class="property">b</span></span><br><span class="line"><span class="comment">// CallExpression</span></span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line"><span class="comment">// SequenceExpression 逗号表达式</span></span><br><span class="line">a, b</span><br><span class="line"><span class="comment">// 括号表达式</span></span><br><span class="line">!(a + b)</span><br></pre></td></tr></table></figure>

<p>另外一些特殊的表达式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">super</span>.<span class="property">a</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">a</span></span><br><span class="line"><span class="title function_">import</span>(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>普通字面量</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NumericLiteral</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">// BooleanLiteral</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="comment">// NullLiteral</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="comment">// 由StringLiteral组成的BinaryExpression</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// RegExpLiteral</span></span><br><span class="line">/[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>]+/g</span><br><span class="line"><span class="comment">// BigIntLiteral</span></span><br><span class="line"><span class="number">1n</span>;</span><br></pre></td></tr></table></figure>

<p>其中 Symbol 没有字面量形式。另外 ECMAScript 规范规定<code>undefined</code>是标识符，默认值是<code>undefined</code>，而不是字面量，这点上和<code>null</code>不同。</p>
<h2 id="模式-Pattern"><a href="#模式-Pattern" class="headerlink" title="模式 Pattern"></a>模式 Pattern</h2><p>解构语法对应的几种特殊形式<br>扩展语法不是表达式，不能独立存在，只能使用在固定的几个地方。</p>
<p>TODO: 添加指向解构语法的参考</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObjectPattern 包括 AssignmentPattern和RestElement</span></span><br><span class="line"><span class="comment">// AssignmentPattern</span></span><br><span class="line"><span class="keyword">const</span> &#123; a = <span class="number">1</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// RestElement</span></span><br><span class="line"><span class="keyword">const</span> &#123; b, ...a &#125; = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayPattern</span></span><br><span class="line"><span class="keyword">const</span> [x, y] = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// RestElement</span></span><br><span class="line"><span class="keyword">const</span> [x, ...y] = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// RestElement a</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">...a</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; ...a &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; b, ...a &#125; = &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释分类单行注释（CommentLine）和多行注释（CommentBlock）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BaseComment</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">start</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">end</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">loc</span>: <span class="title class_">SourceLocation</span></span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;CommentBlock&#x27;</span> | <span class="string">&#x27;CommentLine&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">CommentBlock</span> <span class="keyword">extends</span> <span class="title class_">BaseComment</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;CommentBlock&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">CommentLine</span> <span class="keyword">extends</span> <span class="title class_">BaseComment</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;CommentLine&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Comment</span> = <span class="title class_">CommentBlock</span> | <span class="title class_">CommentLine</span></span><br></pre></td></tr></table></figure>

<p>同一个注释节点可以由多个抽象语法树节点共享，一个节点的注释有三种位置。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// leading comment</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"><span class="comment">/* inner comment */</span> a</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// trailing comment</span></span><br></pre></td></tr></table></figure>

<p>对于函数<code>fun</code>来说有前置注释（leading comment)、内部注释（inner comment）和后置（trailing comment）注释。<code>fun</code>的内部注释对于参数<code>a</code>来说是前置注释。顶层的注释也会包含在<code>Program</code>节点的<code>comments</code>数组属性中。</p>
<h2 id="节点别名-Aliases"><a href="#节点别名-Aliases" class="headerlink" title="节点别名 Aliases"></a>节点别名 Aliases</h2><p>上述节点都是具体的节点类型，若干不同节点还可以使用别名归类到同一个概念下。</p>
<h3 id="Binary"><a href="#Binary" class="headerlink" title="Binary"></a>Binary</h3><p>二元表达式（BinaryExpression）和逻辑表达式（LogicalExpression）都是两个操作数，可以使用 Binary 来引用。</p>
<h3 id="循环相关"><a href="#循环相关" class="headerlink" title="循环相关"></a>循环相关</h3><p>For 循环语句包括普通 for 语句、for-in 语句和 for-of 语句，可以统称为 For；While 语句和 Do-While 语句可以统称为 While；For 和 While 又可以统称为 Loop。</p>
<h3 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h3><p>所有可能代表函数的类型，统称为 Function。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Function</span> =</span><br><span class="line">  | <span class="title class_">FunctionDeclaration</span></span><br><span class="line">  | <span class="title class_">FunctionExpression</span></span><br><span class="line">  | <span class="title class_">ObjectMethod</span></span><br><span class="line">  | <span class="title class_">ArrowFunctionExpression</span></span><br><span class="line">  | <span class="title class_">ClassMethod</span></span><br><span class="line">  | <span class="title class_">ClassPrivateMethod</span></span><br></pre></td></tr></table></figure>

<h3 id="左值类型"><a href="#左值类型" class="headerlink" title="左值类型"></a>左值类型</h3><p>左值类型 LVal 指的是能够出现在赋值表达式左边的节点类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">LVal</span> =</span><br><span class="line">  | <span class="title class_">Identifier</span></span><br><span class="line">  | <span class="title class_">MemberExpression</span></span><br><span class="line">  | <span class="title class_">RestElement</span></span><br><span class="line">  | <span class="title class_">AssignmentPattern</span></span><br><span class="line">  | <span class="title class_">ArrayPattern</span></span><br><span class="line">  | <span class="title class_">ObjectPattern</span></span><br><span class="line">  | <span class="title class_">TSParameterProperty</span></span><br></pre></td></tr></table></figure>

<h3 id="模式类似"><a href="#模式类似" class="headerlink" title="模式类似"></a>模式类似</h3><p>可能作为 Pattern 的几种类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">PatternLike</span> =</span><br><span class="line">  | <span class="title class_">Identifier</span></span><br><span class="line">  | <span class="title class_">RestElement</span></span><br><span class="line">  | <span class="title class_">AssignmentPattern</span></span><br><span class="line">  | <span class="title class_">ArrayPattern</span></span><br><span class="line">  | <span class="title class_">ObjectPattern</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域相关"><a href="#作用域相关" class="headerlink" title="作用域相关"></a>作用域相关</h3><p>作用域相关的节点别名有 Scopable&#x2F;BlockParent&#x2F;Block 等，详细机制可以参考<a href="./plugin-scope.md">插件作用域篇</a>。</p>
<h1 id="AST-相关的工具"><a href="#AST-相关的工具" class="headerlink" title="AST 相关的工具"></a>AST 相关的工具</h1><p>@babel&#x2F;types 包为操作 AST 节点提供了很多辅助函数，涵盖了绝大部分使用场景。对于常见的操作可以先查看下官方是否已经提供，下面列出一些常见的工具函数。</p>
<h2 id="构造-AST"><a href="#构造-AST" class="headerlink" title="构造 AST"></a>构造 AST</h2><p>每个节点在@babel&#x2F;type 中都定义有相关的构造函数，</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 + 2</span></span><br><span class="line">t.<span class="title function_">binaryExpression</span>(<span class="string">&#x27;+&#x27;</span>, t.<span class="title function_">numericLiteral</span>(<span class="number">1</span>), t.<span class="title function_">numericLiteral</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h2 id="查询验证节点类型"><a href="#查询验证节点类型" class="headerlink" title="查询验证节点类型"></a>查询验证节点类型</h2><p>每个节点类型都有<code>is</code>开头的辅助函数判断指定节点参数是否是某种类型的节点，可以接受第二个可选参数指定需要满足的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否</span></span><br><span class="line">t.<span class="title function_">isBinaryExpression</span>(maybeBinaryExpressionNode, &#123; <span class="attr">operator</span>: <span class="string">&#x27;*&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><code>assert</code>开头的辅助函数保证节点必须是指定类型，否则会抛出异常。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保证节点类型</span></span><br><span class="line">t.<span class="title function_">assertBinaryExpression</span>(maybeBinaryExpressionNode, &#123; <span class="attr">operator</span>: <span class="string">&#x27;*&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="多层节点"><a href="#多层节点" class="headerlink" title="多层节点"></a>多层节点</h2><p>TODO: looksLike</p>
<h2 id="从模板构造-AST"><a href="#从模板构造-AST" class="headerlink" title="从模板构造 AST"></a>从模板构造 AST</h2><p>手工构造复杂的 AST 节点树比较麻烦， <code>@babel/template</code>提供了从模板字符串自动生成对应 AST 树的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> template <span class="keyword">from</span> <span class="string">&#x27;@babel/template&#x27;</span></span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">&#x27;@babel/generator&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildRequire = <span class="title function_">template</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  var %%importName%% = require(%%source%%);</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = <span class="title function_">buildRequire</span>(&#123;</span><br><span class="line">  <span class="attr">importName</span>: t.<span class="title function_">identifier</span>(<span class="string">&#x27;myModule&#x27;</span>),</span><br><span class="line">  <span class="attr">source</span>: t.<span class="title function_">stringLiteral</span>(<span class="string">&#x27;my-module&#x27;</span>),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generate</span>(ast).<span class="property">code</span>)</span><br></pre></td></tr></table></figure>

<h2 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h2><p>抽象语法树中每个节点都是唯一的，不能在多个位置重复使用一个节点，对于需要使用两个内容一模一样的节点，可以使用辅助函数进行克隆。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> id = t.<span class="title function_">identifier</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> clonedId = t.<span class="title function_">clone</span>(id)</span><br><span class="line"></span><br><span class="line">id !== clonedId</span><br></pre></td></tr></table></figure>

<h2 id="成员表达式组合"><a href="#成员表达式组合" class="headerlink" title="成员表达式组合"></a>成员表达式组合</h2><p>成员表达式（MemberExpression）可以多个组合起来。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.b</span></span><br><span class="line"><span class="keyword">const</span> m = t.<span class="title function_">memberExpression</span>(t.<span class="title function_">identifier</span>(<span class="string">&#x27;a&#x27;</span>), t.<span class="title function_">identifier</span>(<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> c = t.<span class="title function_">identifier</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.b -&gt; a.b.c</span></span><br><span class="line">t.<span class="title function_">appendToMemberExpression</span>(m, c)</span><br><span class="line"><span class="comment">// a.b -&gt; c.a.b</span></span><br><span class="line">t.<span class="title function_">prependToMemberExpression</span>(m, c)</span><br></pre></td></tr></table></figure>

<h2 id="注释节点"><a href="#注释节点" class="headerlink" title="注释节点"></a>注释节点</h2><p>辅助函数提供了对节点添加、继承、删除注释的操作。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node = t.<span class="title function_">identifier</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加单条注释，可以指明是单行还是多行形式</span></span><br><span class="line">t.<span class="title function_">addComment</span>(node, <span class="string">&#x27;leading&#x27;</span>, <span class="string">&#x27;comment content&#x27;</span>, <span class="string">&#x27;line&#x27;</span>)</span><br><span class="line"><span class="comment">// 添加多条注释</span></span><br><span class="line">t.<span class="title function_">addComments</span>(node, <span class="string">&#x27;leading&#x27;</span>, comments)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子节点node继承父节点parent的所有注释</span></span><br><span class="line">t.<span class="title function_">inheritComments</span>(node, parent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点所有注释</span></span><br><span class="line">t.<span class="title function_">removeComments</span>(node)</span><br></pre></td></tr></table></figure>

<h2 id="值转换为-AST-节点"><a href="#值转换为-AST-节点" class="headerlink" title="值转换为 AST 节点"></a>值转换为 AST 节点</h2><p>使用<code>valueToNode</code>将具体类型未知的运行时值转换为合适的 AST 节点。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&#x27;@babel/types&#x27;</span></span><br><span class="line"></span><br><span class="line">t.<span class="title function_">isNodesEquivalent</span>(t.<span class="title function_">valueToNode</span>(<span class="number">1</span>), t.<span class="title function_">numericLiteral</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Babel</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>AST</tag>
        <tag>Parsing</tag>
      </tags>
  </entry>
</search>
